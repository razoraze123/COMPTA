Code listing for MOTEUR
===== MOTEUR/LICENSE =====
MIT License

Copyright (c) 2025 Lamine

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===== MOTEUR/__init__.py =====

===== MOTEUR/compta/__init__.py =====
from .suppliers import (
    SupplierTab,
    get_suppliers_with_balance,
    get_supplier_transactions,
    init_view as init_supplier_view,
)

__all__ = [
    "SupplierTab",
    "get_suppliers_with_balance",
    "get_supplier_transactions",
    "init_supplier_view",
]

===== MOTEUR/compta/accounting/__init__.py =====

===== MOTEUR/compta/accounting/db.py =====
from __future__ import annotations

from pathlib import Path
from typing import List

from ..db import connect
from ..models import EntryLine
from ..achats.signals import signals as achat_signals

SQL_CREATE_SEQUENCES = """
CREATE TABLE IF NOT EXISTS sequences (
    journal TEXT NOT NULL,
    fiscal_year INTEGER NOT NULL,
    next_number INTEGER NOT NULL,
    PRIMARY KEY (journal, fiscal_year)
)
"""

SQL_CREATE_ACCOUNTS = """
CREATE TABLE IF NOT EXISTS accounts (
    code TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    parent_code TEXT REFERENCES accounts(code)
)"""

SQL_CREATE_ENTRIES = """
CREATE TABLE IF NOT EXISTS entries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    journal TEXT NOT NULL,
    ref TEXT,
    date TEXT NOT NULL,
    memo TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_LINES = """
CREATE TABLE IF NOT EXISTS entry_lines (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE,
    account TEXT NOT NULL,
    debit REAL NOT NULL DEFAULT 0 CHECK(debit>=0),
    credit REAL NOT NULL DEFAULT 0 CHECK(credit>=0),
    description TEXT,
    letter_code TEXT
)"""

SQL_CREATE_JOURNALS = """
CREATE TABLE IF NOT EXISTS journals (
    code TEXT PRIMARY KEY,
    name TEXT NOT NULL
)"""

SQL_INSERT_ENTRY = (
    "INSERT INTO entries (journal, ref, date, memo) VALUES (?,?,?,?)"
)

SQL_INSERT_LINE = (
    "INSERT INTO entry_lines (entry_id, account, debit, credit, description)"
    " VALUES (?,?,?,?,?)"
)

SQL_IDX_ENTRIES_DATE = (
    "CREATE INDEX IF NOT EXISTS idx_entries_date ON entries(date)"
)

SQL_IDX_ENTRIES_REF = (
    "CREATE INDEX IF NOT EXISTS idx_entries_ref ON entries(ref)"
)

SQL_FETCH_LINES = (
    "SELECT account, debit, credit FROM entry_lines WHERE entry_id=?"
)


def _assert_balanced(conn, entry_id: int) -> None:
    cur = conn.execute(SQL_FETCH_LINES, (entry_id,))
    debit = credit = 0.0
    for _, d, c in cur.fetchall():
        debit += d
        credit += c
    if round(debit - credit, 2) != 0.0:
        raise ValueError("Entry not balanced")


def next_sequence(conn, journal: str, fiscal_year: int) -> str:
    cur = conn.execute(
        "SELECT next_number FROM sequences WHERE journal=? AND fiscal_year=?",
        (journal, fiscal_year),
    )
    row = cur.fetchone()
    if row is None:
        next_num = 1
        conn.execute(
            (
                "INSERT INTO sequences (journal, fiscal_year, next_number) "
                "VALUES (?,?,?)"
            ),
            (journal, fiscal_year, 2),
        )
    else:
        next_num = row[0]
        conn.execute(
            (
                "UPDATE sequences SET next_number=? WHERE journal=? "
                "AND fiscal_year=?"
            ),
            (next_num + 1, journal, fiscal_year),
        )
    return f"{journal}{str(fiscal_year)[-2:]}{next_num:05d}"


def init_db(db_path: Path | str) -> None:
    """Create tables for accounting entries."""
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_ACCOUNTS)
        conn.execute(SQL_CREATE_ENTRIES)
        conn.execute(SQL_CREATE_LINES)
        conn.execute(SQL_CREATE_SEQUENCES)
        conn.execute(SQL_CREATE_JOURNALS)
        conn.execute(SQL_IDX_ENTRIES_DATE)
        conn.execute(SQL_IDX_ENTRIES_REF)
        conn.commit()


def create_entry(
    db_path: Path | str,
    journal: str,
    date: str,
    ref: str,
    memo: str,
    lines: List[EntryLine],
) -> int:
    """Create an accounting entry and its lines."""
    with connect(db_path) as conn:
        entry_id = _create_entry(conn, journal, date, ref, memo, lines)
        conn.commit()
        return entry_id


def _create_entry(
    conn,
    journal: str,
    date: str,
    ref: str,
    memo: str,
    lines: List[EntryLine],
) -> int:
    cur = conn.execute(SQL_INSERT_ENTRY, (journal, ref, date, memo))
    entry_id = cur.lastrowid
    for line in lines:
        conn.execute(
            SQL_INSERT_LINE,
            (
                entry_id,
                line.account,
                line.debit,
                line.credit,
                line.description,
            ),
        )
    _assert_balanced(conn, entry_id)
    achat_signals.entry_changed.emit()
    return entry_id


def entry_balanced(db_path: Path | str, entry_id: int) -> bool:
    """Return True if the entry debits equal credits."""
    with connect(db_path) as conn:
        cur = conn.execute(SQL_FETCH_LINES, (entry_id,))
        debit = 0.0
        credit = 0.0
        for row in cur.fetchall():
            debit += row[1]
            credit += row[2]
        return round(debit - credit, 2) == 0.0


def close_fiscal_year(db_path: Path | str, year: int) -> None:
    """Placeholder for fiscal year closing logic."""
    # For demo purposes we only mark the year as closed in a table.
    with connect(db_path) as conn:
        conn.execute(
            (
                "CREATE TABLE IF NOT EXISTS closed_years "
                "(year INTEGER PRIMARY KEY)"
            )
        )
        conn.execute(
            "INSERT OR IGNORE INTO closed_years(year) VALUES (?)",
            (year,),
        )
        conn.commit()


def export_fec(db_path: Path | str, year: int, dest: Path) -> None:
    """Export entries for *year* to a simple FEC-like CSV file."""
    header = [
        "JournalCode",
        "EcritureNum",
        "EcritureDate",
        "CompteNum",
        "Libelle",
        "Debit",
        "Credit",
    ]
    with connect(db_path) as conn, dest.open("w", encoding="utf-8") as fh:
        fh.write(";".join(header) + "\n")
        cur = conn.execute(
            (
                "SELECT id, journal, ref, date FROM entries "
                "WHERE substr(date,1,4)=?"
            ),
            (str(year),),
        )
        for entry_id, journal, ref, date in cur.fetchall():
            lcur = conn.execute(
                (
                    "SELECT account, debit, credit, description FROM "
                    "entry_lines WHERE entry_id=?"
                ),
                (entry_id,),
            )
            line_num = 1
            for account, debit, credit, desc in lcur.fetchall():
                fh.write(
                    f"{journal};{entry_id}-{line_num};{date};{account};"
                    f"{desc or ref};{debit:.2f};{credit:.2f}\n"
                )
                line_num += 1


def apply_letter(db_path: Path | str, code: str, entry_ids: list[int]) -> None:
    """Assign *code* to lines belonging to *entry_ids*."""
    if not entry_ids:
        return
    qmarks = ",".join("?" for _ in entry_ids)
    with connect(db_path) as conn:
        conn.execute(
            (
                "UPDATE entry_lines SET letter_code=? WHERE entry_id "
                f"IN ({qmarks})"
            ),
            [code, *entry_ids],
        )
        conn.commit()


def add_account(
    db_path: Path | str,
    code: str,
    name: str,
    parent_code: str | None = None,
) -> None:
    """Insert or replace an account."""
    with connect(db_path) as conn:
        conn.execute(
            "INSERT OR REPLACE INTO accounts(code, name, parent_code) VALUES (?,?,?)",
            (code, name, parent_code),
        )
        conn.commit()


def update_account(
    db_path: Path | str,
    code: str,
    name: str,
    parent_code: str | None = None,
) -> None:
    """Update the *name* or *parent_code* of an account."""
    with connect(db_path) as conn:
        conn.execute(
            "UPDATE accounts SET name=?, parent_code=? WHERE code=?",
            (name, parent_code, code),
        )
        conn.commit()


def delete_account(db_path: Path | str, code: str) -> None:
    """Remove account with given *code*."""
    with connect(db_path) as conn:
        conn.execute("DELETE FROM accounts WHERE code=?", (code,))
        conn.commit()


def fetch_accounts(db_path: Path | str, prefix: str | None = None):
    """Return all accounts, optionally filtered by *prefix*."""
    with connect(db_path) as conn:
        if prefix:
            cur = conn.execute(
                "SELECT code, name FROM accounts WHERE code LIKE ? ORDER BY code",
                (f"{prefix}%",),
            )
        else:
            cur = conn.execute(
                "SELECT code, name FROM accounts ORDER BY code",
            )
        rows = cur.fetchall()
        return [(r[0], r[1]) for r in rows]


def add_journal(db_path: Path | str, code: str, name: str) -> None:
    """Insert or replace a journal."""
    with connect(db_path) as conn:
        conn.execute(
            "INSERT OR REPLACE INTO journals(code, name) VALUES (?, ?)",
            (code, name),
        )
        conn.commit()


def update_journal(db_path: Path | str, code: str, name: str) -> None:
    """Update the *name* of a journal."""
    with connect(db_path) as conn:
        conn.execute(
            "UPDATE journals SET name=? WHERE code=?",
            (name, code),
        )
        conn.commit()


def delete_journal(db_path: Path | str, code: str) -> None:
    """Delete journal with *code*."""
    with connect(db_path) as conn:
        conn.execute("DELETE FROM journals WHERE code=?", (code,))
        conn.commit()


def fetch_journals(db_path: Path | str):
    """Return list of journals as (code, name)."""
    with connect(db_path) as conn:
        cur = conn.execute(
            "SELECT code, name FROM journals ORDER BY code"
        )
        return [(r[0], r[1]) for r in cur.fetchall()]

===== MOTEUR/compta/accounting/widget.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, Signal
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_account,
    update_account,
    delete_account,
    fetch_accounts,
)

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class AccountWidget(QWidget):
    """Widget for simple account management."""

    accounts_updated = Signal()

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Numéro:"))
        self.code_edit = QLineEdit()
        form_layout.addWidget(self.code_edit)
        form_layout.addWidget(QLabel("Libellé:"))
        self.name_edit = QLineEdit()
        form_layout.addWidget(self.name_edit)
        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_account)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_account)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_account)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Numéro", "Libellé"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_accounts()

    # ------------------------------------------------------------------
    def get_selected_code(self) -> str | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.text()

    # ------------------------------------------------------------------
    def load_accounts(self) -> None:
        self.table.setRowCount(0)
        for code, name in fetch_accounts(db_path):
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(code))
            self.table.setItem(row, 1, QTableWidgetItem(name))
        self.code_edit.clear()
        self.name_edit.clear()

    # ------------------------------------------------------------------
    @Slot()
    def add_account(self) -> None:
        code = self.code_edit.text().strip()
        name = self.name_edit.text().strip()
        if not code or not name:
            QMessageBox.warning(self, "Compte", "Numéro ou libellé manquant")
            return
        add_account(db_path, code, name)
        self.load_accounts()
        self.account_changed()

    # ------------------------------------------------------------------
    @Slot()
    def edit_account(self) -> None:
        code = self.get_selected_code()
        if code is None:
            QMessageBox.warning(self, "Compte", "Sélectionnez un compte")
            return
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Compte", "Libellé manquant")
            return
        update_account(db_path, code, name)
        self.load_accounts()
        self.account_changed()

    # ------------------------------------------------------------------
    @Slot()
    def remove_account(self) -> None:
        code = self.get_selected_code()
        if code is None:
            QMessageBox.warning(self, "Compte", "Sélectionnez un compte")
            return
        delete_account(db_path, code)
        self.load_accounts()
        self.account_changed()

    # ------------------------------------------------------------------
    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_code = self.table.item(row, 0)
        item_name = self.table.item(row, 1)
        if item_code and item_name:
            self.code_edit.setText(item_code.text())
            self.name_edit.setText(item_name.text())

    # Signal used to notify other widgets that the accounts have changed
    def account_changed(self) -> None:
        self.accounts_updated.emit()

===== MOTEUR/compta/achats/__init__.py =====

===== MOTEUR/compta/achats/db.py =====
from __future__ import annotations

from pathlib import Path
from typing import List

from .signals import signals

from ..db import connect
from ..models import EntryLine, Purchase, PurchaseFilter, VatLine

from ..accounting.db import (
    _create_entry,
    init_db as init_accounting,
    next_sequence,
)


def _ensure_account(conn, code: str) -> None:
    conn.execute(
        "INSERT OR IGNORE INTO accounts(code, name) VALUES (?, ?)",
        (code, ""),
    )


def _insert_supplier(conn, name: str) -> int:
    """Insert a supplier and return its id without emitting signals."""
    cur = conn.execute("INSERT INTO suppliers(name) VALUES (?)", (name,))
    return cur.lastrowid


SQL_CREATE_SUPPLIERS = """
CREATE TABLE IF NOT EXISTS suppliers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    vat_number TEXT,
    address TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_PURCHASES = """
CREATE TABLE IF NOT EXISTS purchases (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL,
    piece TEXT NOT NULL,
    supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
    label TEXT NOT NULL,
    ttc_amount REAL NOT NULL CHECK(ttc_amount >= 0),
    vat_rate REAL NOT NULL CHECK(vat_rate IN (0,2.1,5.5,10,20)),
    account_code TEXT NOT NULL REFERENCES accounts(code),
    due_date TEXT NOT NULL,
    payment_status TEXT NOT NULL CHECK(
        payment_status IN ('A_PAYER','PAYE','PARTIEL')
    ),
    payment_date TEXT,
    payment_method TEXT,
    is_advance INTEGER DEFAULT 0 CHECK(is_advance IN (0,1)),
    is_invoice_received INTEGER DEFAULT 1 CHECK(is_invoice_received IN (0,1)),
    attachment_path TEXT,
    created_by TEXT,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_INDEXES = [
    (
        "CREATE UNIQUE INDEX IF NOT EXISTS unq_supplier_piece "
        "ON purchases(supplier_id, piece)"
    ),
    "CREATE INDEX IF NOT EXISTS idx_purchases_date ON purchases(date)",
    (
        "CREATE INDEX IF NOT EXISTS idx_purchases_supplier "
        "ON purchases(supplier_id)"
    ),
]


SQL_INSERT_PURCHASE = """
    INSERT INTO purchases (
        date, piece, supplier_id, label, ttc_amount,
        vat_rate, account_code, due_date, payment_status, payment_date,
        payment_method, is_advance, is_invoice_received, attachment_path,
        created_by
    ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """

SQL_UPDATE_PURCHASE = """
    UPDATE purchases SET
        date=?, piece=?, supplier_id=?, label=?, ttc_amount=?,
        vat_rate=?, account_code=?, due_date=?,
        payment_status=?, payment_date=?, payment_method=?, is_advance=?,
        is_invoice_received=?, attachment_path=?, updated_at=CURRENT_TIMESTAMP
    WHERE id=?
    """

SQL_VAT_SUMMARY = (
    "SELECT vat_rate, "
    "SUM(ROUND(ttc_amount/(1+vat_rate/100),2)) as base, "
    "SUM(ttc_amount - ROUND(ttc_amount/(1+vat_rate/100),2)) as vat "
    "FROM purchases WHERE date BETWEEN ? AND ? GROUP BY vat_rate"
)


def _column_exists(conn, table: str, column: str) -> bool:
    """Return True if *column* exists in *table*."""
    cur = conn.execute(f"PRAGMA table_info({table})")
    return column in [row[1] for row in cur.fetchall()]


def _migrate_schema(conn) -> None:
    """Migrate old purchase schema to the current version."""
    cur = conn.execute(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='purchases'"
    )
    if not cur.fetchone():
        return

    # Add new columns if missing
    if _column_exists(conn, "purchases", "invoice_number") and not _column_exists(
        conn, "purchases", "piece"
    ):
        conn.execute("ALTER TABLE purchases ADD COLUMN piece TEXT")
        conn.execute(
            "UPDATE purchases SET piece=invoice_number WHERE piece IS NULL OR piece=''"
        )

    if _column_exists(conn, "purchases", "ht_amount") and _column_exists(
        conn, "purchases", "vat_amount"
    ) and not _column_exists(conn, "purchases", "ttc_amount"):
        conn.execute("ALTER TABLE purchases ADD COLUMN ttc_amount REAL")
        conn.execute("UPDATE purchases SET ttc_amount=ht_amount + vat_amount")

    # Drop obsolete triggers and indexes from old schema
    conn.execute("DROP TRIGGER IF EXISTS trg_purchase_vat")
    conn.execute("DROP TRIGGER IF EXISTS trg_purchase_vat_up")
    conn.execute("DROP INDEX IF EXISTS unq_supplier_invoice")


def init_db(db_path: Path | str) -> None:
    """Create purchase related tables and migrate old schema if needed."""
    init_accounting(db_path)
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_SUPPLIERS)
        conn.execute(SQL_CREATE_PURCHASES)
        _migrate_schema(conn)
        for sql in SQL_CREATE_INDEXES:
            conn.execute(sql)
        conn.commit()


def add_supplier(
    db_path: Path | str,
    name: str,
    vat_number: str | None = None,
    address: str | None = None,
) -> int:
    """Insert a supplier and return its id."""
    with connect(db_path) as conn:
        cur = conn.execute(
            "INSERT INTO suppliers (name, vat_number, address) VALUES (?,?,?)",
            (name, vat_number, address),
        )
        conn.commit()
        signals.supplier_changed.emit()
        return cur.lastrowid


def add_purchase(db_path: Path | str, pur: Purchase) -> int:
    """Insert *pur* and generate accounting entry."""
    ht = round(pur.ttc_amount / (1 + pur.vat_rate / 100), 2)
    vat = round(pur.ttc_amount - ht, 2)
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            if pur.piece == "AUTO":
                pur.piece = next_sequence(
                    conn, "AC", int(pur.date[:4])
                )
            _ensure_account(conn, pur.account_code)
            cur = conn.execute(
                SQL_INSERT_PURCHASE,
                (
                    pur.date,
                    pur.piece,
                    pur.supplier_id,
                    pur.label,
                    pur.ttc_amount,
                    pur.vat_rate,
                    pur.account_code,
                    pur.due_date,
                    pur.payment_status,
                    pur.payment_date,
                    pur.payment_method,
                    pur.is_advance,
                    pur.is_invoice_received,
                    pur.attachment_path,
                    pur.created_by,
                ),
            )
            pur.id = cur.lastrowid
            credit_account = (
                "4091"
                if pur.is_advance
                else ("408" if not pur.is_invoice_received else "401")
            )
            vat_account = (
                "44562" if pur.account_code.startswith("2") else "44566"
            )
            lines = [
                EntryLine(account=pur.account_code, debit=ht, credit=0.0),
                EntryLine(account=vat_account, debit=vat, credit=0.0),
                EntryLine(
                    account=credit_account,
                    debit=0.0,
                    credit=pur.ttc_amount,
                ),
            ]
            _create_entry(
                conn,
                "ACH",
                pur.date,
                pur.piece,
                pur.label,
                lines,
            )
            conn.commit()
            signals.supplier_changed.emit()
            return pur.id
        except Exception:
            conn.rollback()
            raise


def update_purchase(db_path: Path | str, pur: Purchase) -> None:
    """Update *pur* and recreate its accounting entry."""
    if pur.id is None:
        raise ValueError("Purchase id required")
    ht = round(pur.ttc_amount / (1 + pur.vat_rate / 100), 2)
    vat = round(pur.ttc_amount - ht, 2)
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            if pur.piece == "AUTO":
                pur.piece = next_sequence(
                    conn, "AC", int(pur.date[:4])
                )
            _ensure_account(conn, pur.account_code)
            conn.execute(
                SQL_UPDATE_PURCHASE,
                (
                    pur.date,
                    pur.piece,
                    pur.supplier_id,
                    pur.label,
                    pur.ttc_amount,
                    pur.vat_rate,
                    pur.account_code,
                    pur.due_date,
                    pur.payment_status,
                    pur.payment_date,
                    pur.payment_method,
                    pur.is_advance,
                    pur.is_invoice_received,
                    pur.attachment_path,
                    pur.id,
                ),
            )
            # delete previous entry
            cur = conn.execute(
                "SELECT id FROM entries WHERE journal='ACH' AND ref=?",
                (pur.piece,),
            )
            row = cur.fetchone()
            if row:
                entry_id = row[0]
                conn.execute(
                    "DELETE FROM entry_lines WHERE entry_id=?",
                    (entry_id,),
                )
                conn.execute(
                    "DELETE FROM entries WHERE id=?",
                    (entry_id,),
                )
            credit_account = (
                "4091"
                if pur.is_advance
                else ("408" if not pur.is_invoice_received else "401")
            )
            vat_account = (
                "44562" if pur.account_code.startswith("2") else "44566"
            )
            lines = [
                EntryLine(account=pur.account_code, debit=ht, credit=0.0),
                EntryLine(account=vat_account, debit=vat, credit=0.0),
                EntryLine(
                    account=credit_account,
                    debit=0.0,
                    credit=pur.ttc_amount,
                ),
            ]
            _create_entry(
                conn,
                "ACH",
                pur.date,
                pur.piece,
                pur.label,
                lines,
            )
            conn.commit()
            signals.supplier_changed.emit()
        except Exception:
            conn.rollback()
            raise


def pay_purchase(
    db_path: Path | str,
    purchase_id: int,
    payment_date: str,
    method: str,
    amount: float,
) -> None:
    """Register a payment entry for the purchase."""
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            cur = conn.execute(
                (
                    "SELECT ttc_amount, vat_rate, piece, "
                    "payment_status, is_advance, is_invoice_received "
                    "FROM purchases WHERE id=?"
                ),
                (purchase_id,),
            )
            row = cur.fetchone()
            if not row:
                raise ValueError("Invalid purchase id")
            total = row[0]
            paid = conn.execute(
                (
                    "SELECT COALESCE(SUM(credit),0) FROM entry_lines "
                    "WHERE account='512' AND entry_id IN "
                    "(SELECT id FROM entries WHERE journal='BQ' AND ref=?)"
                ),
                (row[2],),
            ).fetchone()[0]
            status = "PAYE" if amount + paid >= total else "PARTIEL"
            conn.execute(
                (
                    "UPDATE purchases SET payment_status=?, payment_date=?, "
                    "payment_method=? WHERE id=?"
                ),
                (
                    status,
                    payment_date,
                    method,
                    purchase_id,
                ),
            )
            credit_account = (
                "4091" if row[4] else ("408" if not row[5] else "401")
            )
            lines = [
                EntryLine(account=credit_account, debit=amount, credit=0.0),
                EntryLine(account="512", debit=0.0, credit=amount),
            ]
            _create_entry(
                conn,
                "BQ",
                payment_date,
                row[2],
                f"Paiement facture {row[2]}",
                lines,
            )
            conn.commit()
            signals.supplier_changed.emit()
        except Exception:
            conn.rollback()
            raise


def delete_purchase(db_path: Path | str, purchase_id: int) -> None:
    """Delete the purchase and its accounting entry."""
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            cur = conn.execute(
                "SELECT piece FROM purchases WHERE id=?",
                (purchase_id,),
            )
            row = cur.fetchone()
            if not row:
                raise ValueError("Invalid purchase id")
            piece = row[0]

            conn.execute(
                "DELETE FROM purchases WHERE id=?",
                (purchase_id,),
            )

            cur = conn.execute(
                "SELECT id FROM entries WHERE journal='ACH' AND ref=?",
                (piece,),
            )
            row = cur.fetchone()
            if row:
                entry_id = row[0]
                conn.execute(
                    "DELETE FROM entry_lines WHERE entry_id=?",
                    (entry_id,),
                )
                conn.execute(
                    "DELETE FROM entries WHERE id=?",
                    (entry_id,),
                )
            conn.commit()
            signals.supplier_changed.emit()
        except Exception:
            conn.rollback()
            raise


def fetch_purchases(
    db_path: Path | str,
    flt: PurchaseFilter,
) -> List[Purchase]:
    """Return purchases filtered according to *flt*."""
    query = "SELECT * FROM purchases WHERE 1=1"
    params: List = []
    if flt.start:
        query += " AND date >= ?"
        params.append(flt.start)
    if flt.end:
        query += " AND date <= ?"
        params.append(flt.end)
    if flt.supplier_id:
        query += " AND supplier_id = ?"
        params.append(flt.supplier_id)
    if flt.status:
        query += " AND payment_status = ?"
        params.append(flt.status)
    query += " ORDER BY date"
    with connect(db_path) as conn:
        cur = conn.execute(query, params)
        rows = cur.fetchall()
        return [Purchase(**dict(row)) for row in rows]


def fetch_all_purchases(db_path: Path | str):
    """Return purchases as (id, date, label, ttc, due_date, status)."""
    with connect(db_path) as conn:
        cur = conn.execute(
            (
                "SELECT id, date, label, ttc_amount, due_date, payment_status "
                "FROM purchases ORDER BY date"
            )
        )
        return [
            (
                r["id"],
                r["date"],
                r["label"],
                r["ttc_amount"],
                r["due_date"],
                r["payment_status"],
            )
            for r in cur.fetchall()
        ]


def get_vat_summary(
    db_path: Path | str,
    start: str,
    end: str,
) -> List[VatLine]:
    """Return VAT summary per rate between *start* and *end*."""
    with connect(db_path) as conn:
        cur = conn.execute(SQL_VAT_SUMMARY, (start, end))
        return [
            VatLine(rate=r[0], base=r[1], vat=r[2]) for r in cur.fetchall()
        ]

===== MOTEUR/compta/achats/piece_dialog.py =====
from __future__ import annotations

from pathlib import Path
from typing import Iterable, Tuple

from PySide6.QtCore import QDate
from PySide6.QtWidgets import (
    QComboBox,
    QDateEdit,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFormLayout,
    QHBoxLayout,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QDoubleSpinBox,
    QCheckBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..models import Purchase


class PieceDialog(QDialog):
    """Simplified modal form to capture a purchase piece."""

    def __init__(
        self,
        suppliers: Iterable[Tuple[int, str]],
        accounts: Iterable[Tuple[str, str]],
        journals: Iterable[Tuple[str, str]],
        next_piece: str,
        parent=None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("Nouvel achat")
        self.setModal(True)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.journal_combo = QComboBox()
        for code, name in journals:
            self.journal_combo.addItem(code, code)
        form.addRow("Journal", self.journal_combo)

        self.supplier_combo = QComboBox()
        self.supplier_combo.setEditable(True)
        for sid, name in suppliers:
            self.supplier_combo.addItem(name, sid)
        form.addRow("Fournisseur", self.supplier_combo)

        self.account_names = {code: text for code, text in accounts}
        self.account_combo = QComboBox()
        for code, text in accounts:
            self.account_combo.addItem(text, code)
        form.addRow("Compte", self.account_combo)

        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form.addRow("Date", self.date_edit)

        self.piece_edit = QLineEdit(next_piece)
        form.addRow("Pièce", self.piece_edit)

        self.invoice_edit = QLineEdit()
        form.addRow("Facture", self.invoice_edit)

        self.label_edit = QLineEdit()
        form.addRow("Libellé", self.label_edit)

        self.ttc_spin = QDoubleSpinBox()
        self.ttc_spin.setDecimals(2)
        self.ttc_spin.setMaximum(1e9)
        form.addRow("Montant TTC", self.ttc_spin)

        self.credit_note_cb = QCheckBox()
        form.addRow("Avoir", self.credit_note_cb)

        self.vat_combo = QComboBox()
        for rate in [0, 2.1, 5.5, 10, 20]:
            self.vat_combo.addItem(str(rate))
        self.vat_combo.setCurrentText("20")
        form.addRow("Taux TVA", self.vat_combo)

        self.attach_edit = QLineEdit()
        attach_btn = QPushButton("…")
        attach_btn.clicked.connect(self.choose_file)
        attach_layout = QHBoxLayout()
        attach_layout.addWidget(self.attach_edit)
        attach_layout.addWidget(attach_btn)
        form.addRow("Justificatif", attach_layout)

        layout.addLayout(form)

        self.lines_table = QTableWidget(0, 7)
        self.lines_table.setHorizontalHeaderLabels(
            [
                "Compte",
                "Libellé compte",
                "Code TVA",
                "Libellé écriture",
                "Débit",
                "Crédit",
                "Montant TVA",
            ]
        )
        self.lines_table.verticalHeader().setVisible(False)
        self.lines_table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.lines_table)

        # update lines when inputs change
        self.ttc_spin.valueChanged.connect(self._update_lines)
        self.vat_combo.currentIndexChanged.connect(self._update_lines)
        self.account_combo.currentIndexChanged.connect(self._update_lines)
        self.label_edit.textChanged.connect(self._update_lines)

        self._update_lines()

        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel, parent=self
        )
        buttons.accepted.connect(self._validate)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    # --------------------------------------------------------------
    def choose_file(self) -> None:
        path, _ = QFileDialog.getOpenFileName(
            self, "Pièce", str(Path.home()), "PDF (*.pdf)"
        )
        if path:
            self.attach_edit.setText(path)

    # --------------------------------------------------------------
    def _update_lines(self) -> None:
        """Refresh the preview table with generated lines."""
        ht = round(self.ttc_spin.value() / (1 + float(self.vat_combo.currentText()) / 100), 2)
        vat = round(self.ttc_spin.value() - ht, 2)
        account = self.account_combo.currentData()
        vat_account = "44562" if str(account).startswith("2") else "44566"
        credit_account = "401"
        self.lines_table.setRowCount(0)
        desc = self.label_edit.text().strip() or ""
        # purchase line
        row = self.lines_table.rowCount()
        self.lines_table.insertRow(row)
        self.lines_table.setItem(row, 0, QTableWidgetItem(str(account)))
        self.lines_table.setItem(row, 1, QTableWidgetItem(self.account_names.get(account, "")))
        self.lines_table.setItem(row, 2, QTableWidgetItem(""))
        self.lines_table.setItem(row, 3, QTableWidgetItem(desc))
        self.lines_table.setItem(row, 4, QTableWidgetItem(f"{ht:.2f}"))
        self.lines_table.setItem(row, 5, QTableWidgetItem(""))
        self.lines_table.setItem(row, 6, QTableWidgetItem(""))

        # vat line
        row = self.lines_table.rowCount()
        self.lines_table.insertRow(row)
        self.lines_table.setItem(row, 0, QTableWidgetItem(vat_account))
        self.lines_table.setItem(row, 1, QTableWidgetItem("TVA"))
        self.lines_table.setItem(row, 2, QTableWidgetItem(self.vat_combo.currentText()))
        self.lines_table.setItem(row, 3, QTableWidgetItem(desc))
        self.lines_table.setItem(row, 4, QTableWidgetItem(f"{vat:.2f}"))
        self.lines_table.setItem(row, 5, QTableWidgetItem(""))
        self.lines_table.setItem(row, 6, QTableWidgetItem(f"{vat:.2f}"))

        # credit line
        row = self.lines_table.rowCount()
        self.lines_table.insertRow(row)
        self.lines_table.setItem(row, 0, QTableWidgetItem(credit_account))
        self.lines_table.setItem(row, 1, QTableWidgetItem("Fournisseur"))
        self.lines_table.setItem(row, 2, QTableWidgetItem(""))
        self.lines_table.setItem(row, 3, QTableWidgetItem(desc))
        self.lines_table.setItem(row, 4, QTableWidgetItem(""))
        self.lines_table.setItem(row, 5, QTableWidgetItem(f"{self.ttc_spin.value():.2f}"))
        self.lines_table.setItem(row, 6, QTableWidgetItem(""))

    # --------------------------------------------------------------
    def _validate(self) -> None:
        if not self.label_edit.text().strip():
            QMessageBox.warning(self, "Achat", "Libellé manquant")
            return
        if not self.supplier_combo.currentText().strip():
            QMessageBox.warning(self, "Achat", "Fournisseur manquant")
            return
        if self.ttc_spin.value() <= 0:
            QMessageBox.warning(self, "Achat", "Montant TTC invalide")
            return
        self.accept()

    # --------------------------------------------------------------
    def to_purchase(self) -> Purchase:
        date_str = self.date_edit.date().toString("yyyy-MM-dd")
        due = self.date_edit.date().addDays(30).toString("yyyy-MM-dd")
        return Purchase(
            id=None,
            date=date_str,
            piece=self.piece_edit.text() or "AUTO",
            supplier_id=self.supplier_combo.currentData(),
            label=self.label_edit.text().strip(),
            ttc_amount=self.ttc_spin.value(),
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=due,
            payment_status="A_PAYER",
            attachment_path=self.attach_edit.text() or None,
        )

===== MOTEUR/compta/achats/purchase_dialog.py =====
from __future__ import annotations

from pathlib import Path
from typing import Iterable, Tuple

from PySide6.QtCore import QDate
from PySide6.QtWidgets import (
    QComboBox,
    QDateEdit,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFormLayout,
    QHBoxLayout,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QTableWidget,
    QVBoxLayout,
    QDoubleSpinBox,
)

from ..models import Purchase


class PurchaseDialog(QDialog):
    """Modal form to capture a purchase."""

    def __init__(
        self,
        suppliers: Iterable[Tuple[int, str]],
        accounts: Iterable[Tuple[str, str]],
        next_invoice: str,
        parent=None,
    ) -> None:
        super().__init__(parent)
        self.setWindowTitle("Nouvel achat")
        self.setModal(True)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form.addRow("Date", self.date_edit)

        self.supplier_combo = QComboBox()
        self.supplier_combo.setEditable(True)
        for sid, name in suppliers:
            self.supplier_combo.addItem(name, sid)
        form.addRow("Fournisseur", self.supplier_combo)

        self.invoice_edit = QLineEdit(next_invoice)
        form.addRow("Facture", self.invoice_edit)

        self.label_edit = QLineEdit()
        form.addRow("Libellé", self.label_edit)

        self.ht_spin = QDoubleSpinBox()
        self.ht_spin.setDecimals(2)
        self.ht_spin.setMaximum(1e9)
        form.addRow("Montant HT", self.ht_spin)

        self.vat_combo = QComboBox()
        for rate in [0, 2.1, 5.5, 10, 20]:
            self.vat_combo.addItem(str(rate))
        self.vat_combo.setCurrentText("20")
        form.addRow("Taux TVA", self.vat_combo)

        self.account_combo = QComboBox()
        for code, text in accounts:
            self.account_combo.addItem(text, code)
        form.addRow("Compte 6xx", self.account_combo)

        self.attach_edit = QLineEdit()
        attach_btn = QPushButton("…")
        attach_btn.clicked.connect(self.choose_file)
        attach_layout = QHBoxLayout()
        attach_layout.addWidget(self.attach_edit)
        attach_layout.addWidget(attach_btn)
        form.addRow("Pièce", attach_layout)

        layout.addLayout(form)

        self.lines_table = QTableWidget(0, 4)
        self.lines_table.setHorizontalHeaderLabels(
            ["Compte", "Libellé", "Débit", "Crédit"]
        )
        layout.addWidget(self.lines_table)

        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel, parent=self
        )
        buttons.accepted.connect(self._validate)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    # --------------------------------------------------------------
    def choose_file(self) -> None:
        path, _ = QFileDialog.getOpenFileName(
            self, "Pièce", str(Path.home()), "PDF (*.pdf)"
        )
        if path:
            self.attach_edit.setText(path)

    # --------------------------------------------------------------
    def _validate(self) -> None:
        if not self.label_edit.text().strip():
            QMessageBox.warning(self, "Achat", "Libellé manquant")
            return
        if not self.supplier_combo.currentText().strip():
            QMessageBox.warning(self, "Achat", "Fournisseur manquant")
            return
        if self.ht_spin.value() <= 0:
            QMessageBox.warning(self, "Achat", "Montant HT invalide")
            return
        self.accept()

    # --------------------------------------------------------------
    def to_purchase(self) -> Purchase:
        date_str = self.date_edit.date().toString("yyyy-MM-dd")
        due = self.date_edit.date().addDays(30).toString("yyyy-MM-dd")
        return Purchase(
            id=None,
            date=date_str,
            invoice_number=self.invoice_edit.text() or "AUTO",
            supplier_id=self.supplier_combo.currentData(),
            label=self.label_edit.text().strip(),
            ht_amount=self.ht_spin.value(),
            vat_amount=0.0,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=due,
            payment_status="A_PAYER",
            attachment_path=self.attach_edit.text() or None,
        )

===== MOTEUR/compta/achats/signals.py =====
from PySide6.QtCore import QObject, Signal


class AchatSignals(QObject):
    """Signals emitted by the purchases module."""

    supplier_changed = Signal()
    entry_changed = Signal()


signals = AchatSignals()

===== MOTEUR/compta/achats/widget.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional
import sqlite3

from PySide6.QtCore import Qt, Slot, QDate
from PySide6.QtGui import QKeySequence
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QComboBox,
    QFileDialog,
    QPushButton,
    QDialog,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .piece_dialog import PieceDialog

from .db import (
    init_db,
    add_purchase,
    add_supplier,
    update_purchase,
    delete_purchase,
    fetch_all_purchases,
    _insert_supplier,
)
from .signals import signals
from ..models import Purchase
from ..accounting.db import next_sequence, fetch_journals
from ..db import connect

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class AchatWidget(QWidget):
    """Widget pour la gestion des achats."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        self.form_panel = QWidget()
        self.form_panel.setLayout(form_layout)
        form_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form_layout.addWidget(self.date_edit)

        form_layout.addWidget(QLabel("Fournisseur:"))
        self.supplier_combo = QComboBox()
        self.supplier_combo.setEditable(True)
        self.load_suppliers()
        form_layout.addWidget(self.supplier_combo)

        form_layout.addWidget(QLabel("Pièce:"))
        self.piece_edit = QLineEdit()
        self.piece_edit.setText(self.get_next_inv())
        form_layout.addWidget(self.piece_edit)

        form_layout.addWidget(QLabel("Libell\u00e9:"))
        self.label_edit = QLineEdit()
        form_layout.addWidget(self.label_edit)

        form_layout.addWidget(QLabel("Montant TTC:"))
        self.amount_spin = QDoubleSpinBox()
        self.amount_spin.setDecimals(2)
        self.amount_spin.setMaximum(1e9)
        form_layout.addWidget(self.amount_spin)

        form_layout.addWidget(QLabel("Taux TVA:"))
        self.vat_combo = QComboBox()
        for r in [0, 2.1, 5.5, 10, 20]:
            self.vat_combo.addItem(str(r))
        self.vat_combo.setCurrentText("20")
        form_layout.addWidget(self.vat_combo)

        form_layout.addWidget(QLabel("Compte 6xx:"))
        self.account_combo = QComboBox()
        self.load_expense_accounts()
        form_layout.addWidget(self.account_combo)

        form_layout.addWidget(QLabel("\u00c9ch\u00e9ance:"))
        self.due_edit = QDateEdit(QDate.currentDate().addDays(30))
        self.due_edit.setCalendarPopup(True)
        form_layout.addWidget(self.due_edit)

        self.attach_btn = QPushButton("Pi\u00e8ce")
        self.attach_btn.clicked.connect(self.choose_file)
        form_layout.addWidget(self.attach_btn)

        layout.addWidget(self.form_panel)
        self.form_panel.hide()

        btn_layout = QHBoxLayout()
        self.saisir_btn = QPushButton("Saisir…")
        self.saisir_btn.setShortcut(QKeySequence("Ctrl+N"))
        self.saisir_btn.clicked.connect(self.open_dialog)
        btn_layout.addWidget(self.saisir_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_purchase)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_purchase)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(
            [
                "Date",
                "Libell\u00e9",
                "Montant",
            ]
        )
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_purchases()
        self.attachment_path = None

    def get_selected_id(self) -> int | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.data(Qt.UserRole)

    def load_suppliers(self) -> None:
        self.supplier_combo.clear()
        with connect(db_path) as conn:
            for sid, name in conn.execute("SELECT id, name FROM suppliers"):
                self.supplier_combo.addItem(name, sid)

    def load_expense_accounts(self) -> None:
        self.account_combo.clear()
        with connect(db_path) as conn:
            cur = conn.execute("SELECT code, name FROM accounts WHERE code LIKE '6%'")
            for code, name in cur.fetchall():
                self.account_combo.addItem(f"{code} {name}", code)

    @Slot()
    def refresh_accounts(self) -> None:
        """Reload expense accounts from the DB."""
        self.load_expense_accounts()

    def get_next_inv(self) -> str:
        with connect(db_path) as conn:
            return next_sequence(conn, "AC", QDate.currentDate().year())

    def choose_file(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Pièce")
        if path:
            self.attachment_path = path

    @Slot()
    def open_dialog(self) -> None:
        suppliers = [
            (self.supplier_combo.itemData(i), self.supplier_combo.itemText(i))
            for i in range(self.supplier_combo.count())
        ]
        accounts = [
            (self.account_combo.itemData(i), self.account_combo.itemText(i))
            for i in range(self.account_combo.count())
        ]
        journals = fetch_journals(db_path)
        dlg = PieceDialog(suppliers, accounts, journals, self.get_next_inv(), self)
        if dlg.exec() == QDialog.Accepted:
            pur = dlg.to_purchase()
            if pur.supplier_id is None:
                sid = add_supplier(db_path, dlg.supplier_combo.currentText())
                pur.supplier_id = sid
                self.load_suppliers()
            try:
                add_purchase(db_path, pur)
            except sqlite3.IntegrityError:
                QMessageBox.warning(
                    self,
                    "Achat",
                    "Référence déjà utilisée pour ce fournisseur",
                )
                return
            self.load_purchases()
            self.piece_edit.setText(self.get_next_inv())
            self.label_edit.clear()
            self.amount_spin.setValue(0.0)
            self.vat_combo.setCurrentText("20")
            self.due_edit.setDate(QDate.currentDate().addDays(30))
            self.attachment_path = None

    @Slot()
    def add_purchase(self) -> None:
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Achat",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        supplier_id = self.supplier_combo.currentData()
        if supplier_id is None:
            name = self.supplier_combo.currentText().strip()
            if not name:
                QMessageBox.warning(self, "Achat", "Fournisseur manquant")
                return
            with connect(db_path) as conn:
                supplier_id = _insert_supplier(conn, name)
                conn.commit()
            signals.supplier_changed.emit()
            self.load_suppliers()
            idx = self.supplier_combo.findData(supplier_id)
            if idx >= 0:
                self.supplier_combo.setCurrentIndex(idx)
        pur = Purchase(
            id=None,
            date=date,
            piece=self.piece_edit.text() or "AUTO",
            supplier_id=supplier_id,
            label=label,
            ttc_amount=amount,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=self.due_edit.date().toString("yyyy-MM-dd"),
            payment_status="A_PAYER",
            attachment_path=getattr(self, "attachment_path", None),
        )
        try:
            add_purchase(db_path, pur)
        except sqlite3.IntegrityError:
            QMessageBox.warning(
                self,
                "Achat",
                "Référence déjà utilisée pour ce fournisseur",
            )
            return
        self.load_purchases()
        self.attachment_path = None
        self.piece_edit.setText(self.get_next_inv())

    @Slot()
    def edit_purchase(self) -> None:
        purchase_id = self.get_selected_id()
        if purchase_id is None:
            QMessageBox.warning(
                self,
                "Achat",
                "S\u00e9lectionnez un achat",
            )
            return
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Achat",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        supplier_id = self.supplier_combo.currentData()
        if supplier_id is None:
            name = self.supplier_combo.currentText().strip()
            if not name:
                QMessageBox.warning(self, "Achat", "Fournisseur manquant")
                return
            with connect(db_path) as conn:
                supplier_id = _insert_supplier(conn, name)
                conn.commit()
            signals.supplier_changed.emit()
            self.load_suppliers()
            idx = self.supplier_combo.findData(supplier_id)
            if idx >= 0:
                self.supplier_combo.setCurrentIndex(idx)
        pur = Purchase(
            id=purchase_id,
            date=date,
            piece=self.piece_edit.text() or "AUTO",
            supplier_id=supplier_id,
            label=label,
            ttc_amount=amount,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=self.due_edit.date().toString("yyyy-MM-dd"),
            payment_status="A_PAYER",
            attachment_path=getattr(self, "attachment_path", None),
        )
        try:
            update_purchase(db_path, pur)
        except sqlite3.IntegrityError:
            QMessageBox.warning(
                self,
                "Achat",
                "Référence déjà utilisée pour ce fournisseur",
            )
            return
        self.load_purchases()

    @Slot()
    def remove_purchase(self) -> None:
        purchase_id = self.get_selected_id()
        if purchase_id is None:
            QMessageBox.warning(self, "Achat", "S\u00e9lectionnez un achat")
            return
        delete_purchase(db_path, purchase_id)
        self.load_purchases()

    def load_purchases(self) -> None:
        self.table.setRowCount(0)
        today = QDate.currentDate()
        for (
            purchase_id,
            date,
            label,
            amount,
            due,
            status,
        ) in fetch_all_purchases(db_path):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item_date = QTableWidgetItem(date)
            item_date.setData(Qt.UserRole, purchase_id)
            self.table.setItem(row, 0, item_date)
            self.table.setItem(row, 1, QTableWidgetItem(label))
            amt_item = QTableWidgetItem(f"{amount:.2f}")
            if QDate.fromString(due, "yyyy-MM-dd") < today and status == "A_PAYER":
                for col in range(3):
                    self.table.item(row, col).setForeground(Qt.red)
            self.table.setItem(row, 2, amt_item)

    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_date = self.table.item(row, 0)
        item_label = self.table.item(row, 1)
        item_amount = self.table.item(row, 2)
        if item_date and item_label and item_amount:
            self.date_edit.setDate(QDate.fromString(item_date.text(), "yyyy-MM-dd"))
            self.label_edit.setText(item_label.text())
            self.amount_spin.setValue(float(item_amount.text()))
            # restore other fields from DB
            pid = item_date.data(Qt.UserRole)
            with connect(db_path) as conn:
                cur = conn.execute(
                    "SELECT supplier_id, piece, vat_rate, "
                    "account_code, due_date, attachment_path "
                    "FROM purchases WHERE id=?",
                    (pid,),
                )
                r = cur.fetchone()
                if r:
                    idx = self.supplier_combo.findData(r[0])
                    if idx >= 0:
                        self.supplier_combo.setCurrentIndex(idx)
                    self.piece_edit.setText(r[1])
                    idx = self.vat_combo.findText(str(r[2]))
                    if idx >= 0:
                        self.vat_combo.setCurrentIndex(idx)
                    idx = self.account_combo.findData(r[3])
                    if idx >= 0:
                        self.account_combo.setCurrentIndex(idx)
                    self.due_edit.setDate(QDate.fromString(r[4], "yyyy-MM-dd"))
                    self.attachment_path = r[5]

===== MOTEUR/compta/compta.txt =====
Code listing for compta module

===== MOTEUR/compta/__init__.py =====

from .suppliers import (
    SupplierTab,
    get_suppliers_with_balance,
    get_supplier_transactions,
    init_view as init_supplier_view,
)

__all__ = [
    "SupplierTab",
    "get_suppliers_with_balance",
    "get_supplier_transactions",
    "init_supplier_view",
]

===== MOTEUR/compta/accounting/__init__.py =====


===== MOTEUR/compta/accounting/db.py =====

from __future__ import annotations

from pathlib import Path
from typing import List

from ..db import connect
from ..models import EntryLine

SQL_CREATE_SEQUENCES = """
CREATE TABLE IF NOT EXISTS sequences (
    journal TEXT NOT NULL,
    fiscal_year INTEGER NOT NULL,
    next_number INTEGER NOT NULL,
    PRIMARY KEY (journal, fiscal_year)
)
"""

SQL_CREATE_ACCOUNTS = """
CREATE TABLE IF NOT EXISTS accounts (
    code TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    parent_code TEXT REFERENCES accounts(code)
)"""

SQL_CREATE_ENTRIES = """
CREATE TABLE IF NOT EXISTS entries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    journal TEXT NOT NULL,
    ref TEXT,
    date TEXT NOT NULL,
    memo TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_LINES = """
CREATE TABLE IF NOT EXISTS entry_lines (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE,
    account TEXT NOT NULL,
    debit REAL NOT NULL DEFAULT 0 CHECK(debit>=0),
    credit REAL NOT NULL DEFAULT 0 CHECK(credit>=0),
    description TEXT,
    letter_code TEXT
)"""

SQL_INSERT_ENTRY = (
    "INSERT INTO entries (journal, ref, date, memo) VALUES (?,?,?,?)"
)

SQL_INSERT_LINE = (
    "INSERT INTO entry_lines (entry_id, account, debit, credit, description)"
    " VALUES (?,?,?,?,?)"
)

SQL_IDX_ENTRIES_DATE = (
    "CREATE INDEX IF NOT EXISTS idx_entries_date ON entries(date)"
)

SQL_FETCH_LINES = (
    "SELECT account, debit, credit FROM entry_lines WHERE entry_id=?"
)


def _assert_balanced(conn, entry_id: int) -> None:
    cur = conn.execute(SQL_FETCH_LINES, (entry_id,))
    debit = credit = 0.0
    for _, d, c in cur.fetchall():
        debit += d
        credit += c
    if round(debit - credit, 2) != 0.0:
        raise ValueError("Entry not balanced")


def next_sequence(conn, journal: str, fiscal_year: int) -> str:
    cur = conn.execute(
        "SELECT next_number FROM sequences WHERE journal=? AND fiscal_year=?",
        (journal, fiscal_year),
    )
    row = cur.fetchone()
    if row is None:
        next_num = 1
        conn.execute(
            (
                "INSERT INTO sequences (journal, fiscal_year, next_number) "
                "VALUES (?,?,?)"
            ),
            (journal, fiscal_year, 2),
        )
    else:
        next_num = row[0]
        conn.execute(
            (
                "UPDATE sequences SET next_number=? WHERE journal=? "
                "AND fiscal_year=?"
            ),
            (next_num + 1, journal, fiscal_year),
        )
    return f"{journal}{str(fiscal_year)[-2:]}{next_num:05d}"


def init_db(db_path: Path | str) -> None:
    """Create tables for accounting entries."""
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_ACCOUNTS)
        conn.execute(SQL_CREATE_ENTRIES)
        conn.execute(SQL_CREATE_LINES)
        conn.execute(SQL_CREATE_SEQUENCES)
        conn.execute(SQL_IDX_ENTRIES_DATE)
        conn.commit()


def create_entry(
    db_path: Path | str,
    journal: str,
    date: str,
    ref: str,
    memo: str,
    lines: List[EntryLine],
) -> int:
    """Create an accounting entry and its lines."""
    with connect(db_path) as conn:
        entry_id = _create_entry(conn, journal, date, ref, memo, lines)
        conn.commit()
        return entry_id


def _create_entry(
    conn,
    journal: str,
    date: str,
    ref: str,
    memo: str,
    lines: List[EntryLine],
) -> int:
    cur = conn.execute(SQL_INSERT_ENTRY, (journal, ref, date, memo))
    entry_id = cur.lastrowid
    for line in lines:
        conn.execute(
            SQL_INSERT_LINE,
            (
                entry_id,
                line.account,
                line.debit,
                line.credit,
                line.description,
            ),
        )
    _assert_balanced(conn, entry_id)
    return entry_id


def entry_balanced(db_path: Path | str, entry_id: int) -> bool:
    """Return True if the entry debits equal credits."""
    with connect(db_path) as conn:
        cur = conn.execute(SQL_FETCH_LINES, (entry_id,))
        debit = 0.0
        credit = 0.0
        for row in cur.fetchall():
            debit += row[1]
            credit += row[2]
        return round(debit - credit, 2) == 0.0


def close_fiscal_year(db_path: Path | str, year: int) -> None:
    """Placeholder for fiscal year closing logic."""
    # For demo purposes we only mark the year as closed in a table.
    with connect(db_path) as conn:
        conn.execute(
            (
                "CREATE TABLE IF NOT EXISTS closed_years "
                "(year INTEGER PRIMARY KEY)"
            )
        )
        conn.execute(
            "INSERT OR IGNORE INTO closed_years(year) VALUES (?)",
            (year,),
        )
        conn.commit()


def export_fec(db_path: Path | str, year: int, dest: Path) -> None:
    """Export entries for *year* to a simple FEC-like CSV file."""
    header = [
        "JournalCode",
        "EcritureNum",
        "EcritureDate",
        "CompteNum",
        "Libelle",
        "Debit",
        "Credit",
    ]
    with connect(db_path) as conn, dest.open("w", encoding="utf-8") as fh:
        fh.write(";".join(header) + "\n")
        cur = conn.execute(
            (
                "SELECT id, journal, ref, date FROM entries "
                "WHERE substr(date,1,4)=?"
            ),
            (str(year),),
        )
        for entry_id, journal, ref, date in cur.fetchall():
            lcur = conn.execute(
                (
                    "SELECT account, debit, credit, description FROM "
                    "entry_lines WHERE entry_id=?"
                ),
                (entry_id,),
            )
            line_num = 1
            for account, debit, credit, desc in lcur.fetchall():
                fh.write(
                    f"{journal};{entry_id}-{line_num};{date};{account};"
                    f"{desc or ref};{debit:.2f};{credit:.2f}\n"
                )
                line_num += 1


def apply_letter(db_path: Path | str, code: str, entry_ids: list[int]) -> None:
    """Assign *code* to lines belonging to *entry_ids*."""
    if not entry_ids:
        return
    qmarks = ",".join("?" for _ in entry_ids)
    with connect(db_path) as conn:
        conn.execute(
            (
                "UPDATE entry_lines SET letter_code=? WHERE entry_id "
                f"IN ({qmarks})"
            ),
            [code, *entry_ids],
        )
        conn.commit()

def add_account(
    db_path: Path | str,
    code: str,
    name: str,
    parent_code: str | None = None,
) -> None:
    """Insert or replace an account."""
    with connect(db_path) as conn:
        conn.execute(
            "INSERT OR REPLACE INTO accounts(code, name, parent_code) VALUES (?,?,?)",
            (code, name, parent_code),
        )
        conn.commit()


def update_account(
    db_path: Path | str,
    code: str,
    name: str,
    parent_code: str | None = None,
) -> None:
    """Update the *name* or *parent_code* of an account."""
    with connect(db_path) as conn:
        conn.execute(
            "UPDATE accounts SET name=?, parent_code=? WHERE code=?",
            (name, parent_code, code),
        )
        conn.commit()


def delete_account(db_path: Path | str, code: str) -> None:
    """Remove account with given *code*."""
    with connect(db_path) as conn:
        conn.execute("DELETE FROM accounts WHERE code=?", (code,))
        conn.commit()


def fetch_accounts(db_path: Path | str, prefix: str | None = None):
    """Return all accounts, optionally filtered by *prefix*."""
    with connect(db_path) as conn:
        if prefix:
            cur = conn.execute(
                "SELECT code, name FROM accounts WHERE code LIKE ? ORDER BY code",
                (f"{prefix}%",),
            )
        else:
            cur = conn.execute(
                "SELECT code, name FROM accounts ORDER BY code",
            )
        return cur.fetchall()

===== MOTEUR/compta/achats/__init__.py =====


===== MOTEUR/compta/achats/db.py =====

from __future__ import annotations

from pathlib import Path
from typing import List

from ..db import connect
from ..models import EntryLine, Purchase, PurchaseFilter, VatLine
from ..accounting.db import (
    _create_entry,
    init_db as init_accounting,
    next_sequence,
)


def _ensure_account(conn, code: str) -> None:
    conn.execute(
        "INSERT OR IGNORE INTO accounts(code, name) VALUES (?, ?)",
        (code, ""),
    )


SQL_CREATE_SUPPLIERS = """
CREATE TABLE IF NOT EXISTS suppliers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    vat_number TEXT,
    address TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_PURCHASES = """
CREATE TABLE IF NOT EXISTS purchases (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL,
    invoice_number TEXT NOT NULL,
    supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
    label TEXT NOT NULL,
    ht_amount REAL NOT NULL CHECK(ht_amount >= 0),
    vat_amount REAL NOT NULL CHECK(vat_amount >= 0),
    vat_rate REAL NOT NULL CHECK(vat_rate IN (0,2.1,5.5,10,20)),
    account_code TEXT NOT NULL REFERENCES accounts(code),
    due_date TEXT NOT NULL,
    payment_status TEXT NOT NULL CHECK(
        payment_status IN ('A_PAYER','PAYE','PARTIEL')
    ),
    payment_date TEXT,
    payment_method TEXT,
    is_advance INTEGER DEFAULT 0 CHECK(is_advance IN (0,1)),
    is_invoice_received INTEGER DEFAULT 1 CHECK(is_invoice_received IN (0,1)),
    attachment_path TEXT,
    created_by TEXT,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_INDEXES = [
    (
        "CREATE UNIQUE INDEX IF NOT EXISTS unq_supplier_invoice "
        "ON purchases(supplier_id, invoice_number)"
    ),
    "CREATE INDEX IF NOT EXISTS idx_purchases_date ON purchases(date)",
    (
        "CREATE INDEX IF NOT EXISTS idx_purchases_supplier "
        "ON purchases(supplier_id)"
    ),
]

SQL_TRIGGER_INSERT = """
CREATE TRIGGER IF NOT EXISTS trg_purchase_vat
BEFORE INSERT ON purchases
FOR EACH ROW
BEGIN
  SELECT CASE
    WHEN ROUND(NEW.ht_amount * NEW.vat_rate / 100, 2) <> NEW.vat_amount
    THEN RAISE(FAIL, 'VAT amount inconsistent with HT × rate')
  END;
END;
"""

SQL_TRIGGER_UPDATE = """
CREATE TRIGGER IF NOT EXISTS trg_purchase_vat_up
BEFORE UPDATE ON purchases
FOR EACH ROW
BEGIN
  SELECT CASE
    WHEN ROUND(NEW.ht_amount * NEW.vat_rate / 100, 2) <> NEW.vat_amount
    THEN RAISE(FAIL, 'VAT amount inconsistent with HT × rate')
  END;
END;
"""

SQL_INSERT_PURCHASE = """
    INSERT INTO purchases (
        date, invoice_number, supplier_id, label, ht_amount, vat_amount,
        vat_rate, account_code, due_date, payment_status, payment_date,
        payment_method, is_advance, is_invoice_received, attachment_path,
        created_by
    ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """

SQL_UPDATE_PURCHASE = """
    UPDATE purchases SET
        date=?, invoice_number=?, supplier_id=?, label=?, ht_amount=?,
        vat_amount=?, vat_rate=?, account_code=?, due_date=?,
        payment_status=?, payment_date=?, payment_method=?, is_advance=?,
        is_invoice_received=?, attachment_path=?, updated_at=CURRENT_TIMESTAMP
    WHERE id=?
    """

SQL_VAT_SUMMARY = (
    "SELECT vat_rate, SUM(ht_amount) as base, SUM(vat_amount) as vat"
    " FROM purchases WHERE date BETWEEN ? AND ? GROUP BY vat_rate"
)


def init_db(db_path: Path | str) -> None:
    """Create purchase related tables."""
    init_accounting(db_path)
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_SUPPLIERS)
        conn.execute(SQL_CREATE_PURCHASES)
        for sql in SQL_CREATE_INDEXES:
            conn.execute(sql)
        conn.execute(SQL_TRIGGER_INSERT)
        conn.execute(SQL_TRIGGER_UPDATE)
        conn.commit()


def add_purchase(db_path: Path | str, pur: Purchase) -> int:
    """Insert *pur* and generate accounting entry."""
    vat = round(pur.ht_amount * pur.vat_rate / 100, 2)
    pur.vat_amount = vat
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            if pur.invoice_number == "AUTO":
                pur.invoice_number = next_sequence(
                    conn, "AC", int(pur.date[:4])
                )
            _ensure_account(conn, pur.account_code)
            cur = conn.execute(
                SQL_INSERT_PURCHASE,
                (
                    pur.date,
                    pur.invoice_number,
                    pur.supplier_id,
                    pur.label,
                    pur.ht_amount,
                    pur.vat_amount,
                    pur.vat_rate,
                    pur.account_code,
                    pur.due_date,
                    pur.payment_status,
                    pur.payment_date,
                    pur.payment_method,
                    pur.is_advance,
                    pur.is_invoice_received,
                    pur.attachment_path,
                    pur.created_by,
                ),
            )
            pur.id = cur.lastrowid
            credit_account = (
                "4091"
                if pur.is_advance
                else ("408" if not pur.is_invoice_received else "401")
            )
            vat_account = (
                "44562" if pur.account_code.startswith("2") else "44566"
            )
            lines = [
                EntryLine(
                    account=pur.account_code,
                    debit=pur.ht_amount,
                    credit=0.0,
                ),
                EntryLine(
                    account=vat_account, debit=pur.vat_amount, credit=0.0
                ),
                EntryLine(
                    account=credit_account,
                    debit=0.0,
                    credit=pur.ht_amount + pur.vat_amount,
                ),
            ]
            _create_entry(
                conn,
                "ACH",
                pur.date,
                pur.invoice_number,
                pur.label,
                lines,
            )
            conn.commit()
            return pur.id
        except Exception:
            conn.rollback()
            raise


def update_purchase(db_path: Path | str, pur: Purchase) -> None:
    """Update *pur* and recreate its accounting entry."""
    if pur.id is None:
        raise ValueError("Purchase id required")
    vat = round(pur.ht_amount * pur.vat_rate / 100, 2)
    pur.vat_amount = vat
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            if pur.invoice_number == "AUTO":
                pur.invoice_number = next_sequence(
                    conn, "AC", int(pur.date[:4])
                )
            _ensure_account(conn, pur.account_code)
            conn.execute(
                SQL_UPDATE_PURCHASE,
                (
                    pur.date,
                    pur.invoice_number,
                    pur.supplier_id,
                    pur.label,
                    pur.ht_amount,
                    pur.vat_amount,
                    pur.vat_rate,
                    pur.account_code,
                    pur.due_date,
                    pur.payment_status,
                    pur.payment_date,
                    pur.payment_method,
                    pur.is_advance,
                    pur.is_invoice_received,
                    pur.attachment_path,
                    pur.id,
                ),
            )
            # delete previous entry
            cur = conn.execute(
                "SELECT id FROM entries WHERE journal='ACH' AND ref=?",
                (pur.invoice_number,),
            )
            row = cur.fetchone()
            if row:
                entry_id = row[0]
                conn.execute(
                    "DELETE FROM entry_lines WHERE entry_id=?",
                    (entry_id,),
                )
                conn.execute(
                    "DELETE FROM entries WHERE id=?",
                    (entry_id,),
                )
            credit_account = (
                "4091"
                if pur.is_advance
                else ("408" if not pur.is_invoice_received else "401")
            )
            vat_account = (
                "44562" if pur.account_code.startswith("2") else "44566"
            )
            lines = [
                EntryLine(
                    account=pur.account_code,
                    debit=pur.ht_amount,
                    credit=0.0,
                ),
                EntryLine(
                    account=vat_account, debit=pur.vat_amount, credit=0.0
                ),
                EntryLine(
                    account=credit_account,
                    debit=0.0,
                    credit=pur.ht_amount + pur.vat_amount,
                ),
            ]
            _create_entry(
                conn,
                "ACH",
                pur.date,
                pur.invoice_number,
                pur.label,
                lines,
            )
            conn.commit()
        except Exception:
            conn.rollback()
            raise


def pay_purchase(
    db_path: Path | str,
    purchase_id: int,
    payment_date: str,
    method: str,
    amount: float,
) -> None:
    """Register a payment entry for the purchase."""
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            cur = conn.execute(
                (
                    "SELECT ht_amount, vat_amount, invoice_number, "
                    "payment_status, is_advance, is_invoice_received "
                    "FROM purchases WHERE id=?"
                ),
                (purchase_id,),
            )
            row = cur.fetchone()
            if not row:
                raise ValueError("Invalid purchase id")
            total = row[0] + row[1]
            paid = conn.execute(
                (
                    "SELECT COALESCE(SUM(credit),0) FROM entry_lines "
                    "WHERE account='512' AND entry_id IN "
                    "(SELECT id FROM entries WHERE journal='BQ' AND ref=?)"
                ),
                (row[2],),
            ).fetchone()[0]
            status = "PAYE" if amount + paid >= total else "PARTIEL"
            conn.execute(
                (
                    "UPDATE purchases SET payment_status=?, payment_date=?, "
                    "payment_method=? WHERE id=?"
                ),
                (
                    status,
                    payment_date,
                    method,
                    purchase_id,
                ),
            )
            credit_account = (
                "4091" if row[4] else ("408" if not row[5] else "401")
            )
            lines = [
                EntryLine(account=credit_account, debit=amount, credit=0.0),
                EntryLine(account="512", debit=0.0, credit=amount),
            ]
            _create_entry(
                conn,
                "BQ",
                payment_date,
                row[2],
                f"Paiement facture {row[2]}",
                lines,
            )
            conn.commit()
        except Exception:
            conn.rollback()
            raise


def delete_purchase(db_path: Path | str, purchase_id: int) -> None:
    """Delete the purchase and its accounting entry."""
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            cur = conn.execute(
                "SELECT invoice_number FROM purchases WHERE id=?",
                (purchase_id,),
            )
            row = cur.fetchone()
            if not row:
                raise ValueError("Invalid purchase id")
            invoice = row[0]

            conn.execute(
                "DELETE FROM purchases WHERE id=?",
                (purchase_id,),
            )

            cur = conn.execute(
                "SELECT id FROM entries WHERE journal='ACH' AND ref=?",
                (invoice,),
            )
            row = cur.fetchone()
            if row:
                entry_id = row[0]
                conn.execute(
                    "DELETE FROM entry_lines WHERE entry_id=?",
                    (entry_id,),
                )
                conn.execute(
                    "DELETE FROM entries WHERE id=?",
                    (entry_id,),
                )
            conn.commit()
        except Exception:
            conn.rollback()
            raise


def fetch_purchases(
    db_path: Path | str,
    flt: PurchaseFilter,
) -> List[Purchase]:
    """Return purchases filtered according to *flt*."""
    query = "SELECT * FROM purchases WHERE 1=1"
    params: List = []
    if flt.start:
        query += " AND date >= ?"
        params.append(flt.start)
    if flt.end:
        query += " AND date <= ?"
        params.append(flt.end)
    if flt.supplier_id:
        query += " AND supplier_id = ?"
        params.append(flt.supplier_id)
    if flt.status:
        query += " AND payment_status = ?"
        params.append(flt.status)
    query += " ORDER BY date"
    with connect(db_path) as conn:
        cur = conn.execute(query, params)
        rows = cur.fetchall()
        return [Purchase(**dict(row)) for row in rows]


def fetch_all_purchases(db_path: Path | str):
    """Return purchases as (id, date, label, ttc, due_date, status)."""
    with connect(db_path) as conn:
        cur = conn.execute(
            (
                "SELECT id, date, label, ht_amount + vat_amount as ttc, "
                "due_date, payment_status FROM purchases ORDER BY date"
            )
        )
        return [
            (
                r["id"],
                r["date"],
                r["label"],
                r["ttc"],
                r["due_date"],
                r["payment_status"],
            )
            for r in cur.fetchall()
        ]


def get_vat_summary(
    db_path: Path | str,
    start: str,
    end: str,
) -> List[VatLine]:
    """Return VAT summary per rate between *start* and *end*."""
    with connect(db_path) as conn:
        cur = conn.execute(SQL_VAT_SUMMARY, (start, end))
        return [
            VatLine(rate=r[0], base=r[1], vat=r[2]) for r in cur.fetchall()
        ]

===== MOTEUR/compta/achats/widget.py =====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, QDate
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QComboBox,
    QFileDialog,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_purchase,
    update_purchase,
    delete_purchase,
    fetch_all_purchases,
)
from ..models import Purchase
from ..accounting.db import next_sequence
from ..db import connect

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class AchatWidget(QWidget):
    """Widget pour la gestion des achats."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form_layout.addWidget(self.date_edit)

        form_layout.addWidget(QLabel("Fournisseur:"))
        self.supplier_combo = QComboBox()
        self.supplier_combo.setEditable(True)
        self.load_suppliers()
        form_layout.addWidget(self.supplier_combo)

        form_layout.addWidget(QLabel("Facture:"))
        self.invoice_edit = QLineEdit()
        self.invoice_edit.setText(self.get_next_inv())
        form_layout.addWidget(self.invoice_edit)

        form_layout.addWidget(QLabel("Libell\u00e9:"))
        self.label_edit = QLineEdit()
        form_layout.addWidget(self.label_edit)

        form_layout.addWidget(QLabel("Montant HT:"))
        self.amount_spin = QDoubleSpinBox()
        self.amount_spin.setDecimals(2)
        self.amount_spin.setMaximum(1e9)
        form_layout.addWidget(self.amount_spin)

        form_layout.addWidget(QLabel("Taux TVA:"))
        self.vat_combo = QComboBox()
        for r in [0, 2.1, 5.5, 10, 20]:
            self.vat_combo.addItem(str(r))
        self.vat_combo.setCurrentText("20")
        form_layout.addWidget(self.vat_combo)

        form_layout.addWidget(QLabel("Compte 6xx:"))
        self.account_combo = QComboBox()
        self.load_expense_accounts()
        form_layout.addWidget(self.account_combo)

        form_layout.addWidget(QLabel("\u00c9ch\u00e9ance:"))
        self.due_edit = QDateEdit(QDate.currentDate().addDays(30))
        self.due_edit.setCalendarPopup(True)
        form_layout.addWidget(self.due_edit)

        self.attach_btn = QPushButton("Pi\u00e8ce")
        self.attach_btn.clicked.connect(self.choose_file)
        form_layout.addWidget(self.attach_btn)

        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_purchase)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_purchase)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_purchase)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(
            [
                "Date",
                "Libell\u00e9",
                "Montant",
            ]
        )
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_purchases()
        self.attachment_path = None

    def get_selected_id(self) -> int | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.data(Qt.UserRole)

    def load_suppliers(self) -> None:
        self.supplier_combo.clear()
        with connect(db_path) as conn:
            for sid, name in conn.execute("SELECT id, name FROM suppliers"):
                self.supplier_combo.addItem(name, sid)

    def load_expense_accounts(self) -> None:
        self.account_combo.clear()
        with connect(db_path) as conn:
            cur = conn.execute(
                "SELECT code, name FROM accounts WHERE code LIKE '6%'"
            )
            for code, name in cur.fetchall():
                self.account_combo.addItem(f"{code} {name}", code)

    def get_next_inv(self) -> str:
        with connect(db_path) as conn:
            return next_sequence(conn, "AC", QDate.currentDate().year())

    def choose_file(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Pièce")
        if path:
            self.attachment_path = path

    @Slot()
    def add_purchase(self) -> None:
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Achat",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        supplier_id = self.supplier_combo.currentData()
        if supplier_id is None:
            name = self.supplier_combo.currentText().strip()
            if not name:
                QMessageBox.warning(self, "Achat", "Fournisseur manquant")
                return
            with connect(db_path) as conn:
                supplier_id = _insert_supplier(conn, name)
                conn.commit()
            signals.supplier_changed.emit()
            self.load_suppliers()
            idx = self.supplier_combo.findData(supplier_id)
            if idx >= 0:
                self.supplier_combo.setCurrentIndex(idx)
        pur = Purchase(
            id=None,
            date=date,
            invoice_number=self.invoice_edit.text() or "AUTO",
            supplier_id=supplier_id,
            label=label,
            ht_amount=amount,
            vat_amount=0.0,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=self.due_edit.date().toString("yyyy-MM-dd"),
            payment_status="A_PAYER",
            attachment_path=getattr(self, "attachment_path", None),
        )
        add_purchase(db_path, pur)
        self.load_purchases()
        self.attachment_path = None
        self.invoice_edit.setText(self.get_next_inv())

    @Slot()
    def edit_purchase(self) -> None:
        purchase_id = self.get_selected_id()
        if purchase_id is None:
            QMessageBox.warning(
                self,
                "Achat",
                "S\u00e9lectionnez un achat",
            )
            return
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Achat",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        supplier_id = self.supplier_combo.currentData()
        if supplier_id is None:
            name = self.supplier_combo.currentText().strip()
            if not name:
                QMessageBox.warning(self, "Achat", "Fournisseur manquant")
                return
            with connect(db_path) as conn:
                supplier_id = _insert_supplier(conn, name)
                conn.commit()
            signals.supplier_changed.emit()
            self.load_suppliers()
            idx = self.supplier_combo.findData(supplier_id)
            if idx >= 0:
                self.supplier_combo.setCurrentIndex(idx)
        pur = Purchase(
            id=purchase_id,
            date=date,
            invoice_number=self.invoice_edit.text() or "AUTO",
            supplier_id=supplier_id,
            label=label,
            ht_amount=amount,
            vat_amount=0.0,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=self.due_edit.date().toString("yyyy-MM-dd"),
            payment_status="A_PAYER",
            attachment_path=getattr(self, "attachment_path", None),
        )
        update_purchase(db_path, pur)
        self.load_purchases()

    @Slot()
    def remove_purchase(self) -> None:
        purchase_id = self.get_selected_id()
        if purchase_id is None:
            QMessageBox.warning(self, "Achat", "S\u00e9lectionnez un achat")
            return
        delete_purchase(db_path, purchase_id)
        self.load_purchases()

    def load_purchases(self) -> None:
        self.table.setRowCount(0)
        today = QDate.currentDate()
        for (
            purchase_id,
            date,
            label,
            amount,
            due,
            status,
        ) in fetch_all_purchases(db_path):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item_date = QTableWidgetItem(date)
            item_date.setData(Qt.UserRole, purchase_id)
            self.table.setItem(row, 0, item_date)
            self.table.setItem(row, 1, QTableWidgetItem(label))
            amt_item = QTableWidgetItem(f"{amount:.2f}")
            if (
                QDate.fromString(due, "yyyy-MM-dd") < today
                and status == "A_PAYER"
            ):
                for col in range(3):
                    self.table.item(row, col).setForeground(Qt.red)
            self.table.setItem(row, 2, amt_item)

    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_date = self.table.item(row, 0)
        item_label = self.table.item(row, 1)
        item_amount = self.table.item(row, 2)
        if item_date and item_label and item_amount:
            self.date_edit.setDate(
                QDate.fromString(item_date.text(), "yyyy-MM-dd")
            )
            self.label_edit.setText(item_label.text())
            self.amount_spin.setValue(float(item_amount.text()))
            # restore other fields from DB
            pid = item_date.data(Qt.UserRole)
            with connect(db_path) as conn:
                cur = conn.execute(
                    "SELECT supplier_id, invoice_number, vat_rate, "
                    "account_code, due_date, attachment_path "
                    "FROM purchases WHERE id=?",
                    (pid,),
                )
                r = cur.fetchone()
                if r:
                    idx = self.supplier_combo.findData(r[0])
                    if idx >= 0:
                        self.supplier_combo.setCurrentIndex(idx)
                    self.invoice_edit.setText(r[1])
                    idx = self.vat_combo.findText(str(r[2]))
                    if idx >= 0:
                        self.vat_combo.setCurrentIndex(idx)
                    idx = self.account_combo.findData(r[3])
                    if idx >= 0:
                        self.account_combo.setCurrentIndex(idx)
                    self.due_edit.setDate(QDate.fromString(r[4], "yyyy-MM-dd"))
                    self.attachment_path = r[5]

===== MOTEUR/compta/dashboard/__init__.py =====


===== MOTEUR/compta/dashboard/widget.py =====

from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Optional
import json

from PySide6.QtCore import Slot, Signal
from PySide6.QtWidgets import (
    QLabel,
    QVBoxLayout,
    QWidget,
    QCheckBox,
    QHBoxLayout,
    QPushButton,
)

from ..achats.db import fetch_all_purchases, init_db

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database used in AchatWidget
DB_PATH = BASE_DIR / "compta.db"
CONFIG_PATH = Path(__file__).with_name("config.json")

DEFAULT_CONFIG = {
    "show_total_count": True,
    "show_total_amount": True,
    "show_avg_per_month": True,
    "show_chart": True,
}

try:
    import matplotlib

    matplotlib.use("QtAgg")  # Use Qt backend for PySide6
    from matplotlib.backends.backend_qtagg import (
        FigureCanvasQTAgg as FigureCanvas,
    )
    from matplotlib.figure import Figure

    MPL_AVAILABLE = True
except Exception:  # pragma: no cover - matplotlib is optional
    MPL_AVAILABLE = False


def load_dashboard_config() -> dict:
    """Return dashboard configuration from :data:`CONFIG_PATH`."""
    if CONFIG_PATH.exists():
        try:
            with CONFIG_PATH.open("r", encoding="utf-8") as fh:
                data = json.load(fh)
            return {**DEFAULT_CONFIG, **{k: bool(v) for k, v in data.items()}}
        except Exception:
            return DEFAULT_CONFIG.copy()
    CONFIG_PATH.write_text(
        json.dumps(DEFAULT_CONFIG, indent=2, ensure_ascii=False)
    )
    return DEFAULT_CONFIG.copy()


def save_dashboard_config(config: dict) -> None:
    """Write *config* to :data:`CONFIG_PATH`."""
    with CONFIG_PATH.open("w", encoding="utf-8") as fh:
        json.dump(config, fh, ensure_ascii=False, indent=2)


def build_summary_text(
    total: int,
    amount: float,
    avg: float,
    config: dict,
) -> str:
    """Return summary text based on *config*."""
    lines: list[str] = []
    if config.get("show_total_count", True):
        lines.append(f"Nombre d'achats : {total}")
    if config.get("show_total_amount", True):
        lines.append(f"Total : {amount:.2f} \u20ac")
    if config.get("show_avg_per_month", True):
        lines.append(f"Moyenne par mois : {avg:.2f} \u20ac")
    return "\n".join(lines)


class DashboardWidget(QWidget):
    """Widget displaying purchase statistics with an optional graph."""

    journal_requested = Signal()
    grand_livre_requested = Signal()
    scraping_summary_requested = Signal()

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(DB_PATH)

        self.config = load_dashboard_config()

        layout = QVBoxLayout(self)

        nav_layout = QHBoxLayout()
        journal_btn = QPushButton("Journal")
        journal_btn.clicked.connect(self.journal_requested.emit)
        nav_layout.addWidget(journal_btn)

        grand_btn = QPushButton("Grand Livre")
        grand_btn.clicked.connect(self.grand_livre_requested.emit)
        nav_layout.addWidget(grand_btn)

        scrap_btn = QPushButton("Dernier scraping")
        scrap_btn.clicked.connect(self.scraping_summary_requested.emit)
        nav_layout.addWidget(scrap_btn)
        layout.addLayout(nav_layout)

        self.summary_label = QLabel()
        layout.addWidget(self.summary_label)

        if MPL_AVAILABLE:
            self.figure = Figure(figsize=(5, 3))
            self.canvas = FigureCanvas(self.figure)
            layout.addWidget(self.canvas)
        else:  # pragma: no cover - depends on matplotlib being installed
            self.figure = None
            self.canvas = None
            layout.addWidget(
                QLabel("matplotlib requis pour l'affichage du graphique")
            )

        config_layout = QHBoxLayout()
        self.count_cb = QCheckBox("Nombre")
        self.amount_cb = QCheckBox("Total")
        self.avg_cb = QCheckBox("Moyenne/mois")
        self.chart_cb = QCheckBox("Graphique")
        for key, cb in [
            ("show_total_count", self.count_cb),
            ("show_total_amount", self.amount_cb),
            ("show_avg_per_month", self.avg_cb),
            ("show_chart", self.chart_cb),
        ]:
            cb.setChecked(self.config.get(key, True))
            cb.stateChanged.connect(self._config_changed)
            config_layout.addWidget(cb)
        layout.addLayout(config_layout)

        self.refresh()

    # ------------------------------------------------------------------
    @Slot()
    def _config_changed(self) -> None:
        """Persist config and refresh widgets when checkboxes change."""
        self.config = {
            "show_total_count": self.count_cb.isChecked(),
            "show_total_amount": self.amount_cb.isChecked(),
            "show_avg_per_month": self.avg_cb.isChecked(),
            "show_chart": self.chart_cb.isChecked(),
        }
        save_dashboard_config(self.config)
        self.refresh()

    # ------------------------------------------------------------------
    def _load_purchases(self) -> list[tuple[int, str, str, float, str, str]]:
        return fetch_all_purchases(DB_PATH)

    def _compute_metrics(self, rows: list[tuple[int, str, str, float, str, str]]):
        total_count = len(rows)
        total_amount = sum(r[3] for r in rows)

        by_month: dict[str, float] = defaultdict(float)
        for _pid, date_str, _label, amount, *_ in rows:
            try:
                dt = datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                continue
            key = dt.strftime("%Y-%m")
            by_month[key] += amount
        avg_per_month = total_amount / len(by_month) if by_month else 0.0
        return total_count, total_amount, avg_per_month, by_month

    def _update_summary(self, total: int, amount: float, avg: float) -> None:
        text = build_summary_text(total, amount, avg, self.config)
        self.summary_label.setText(text)
        self.summary_label.setVisible(bool(text))

    def _update_chart(self, by_month: dict[str, float]) -> None:
        if not MPL_AVAILABLE or not self.figure:
            return
        if not self.config.get("show_chart", True):
            if self.canvas:
                self.canvas.hide()
            return
        if self.canvas:
            self.canvas.show()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        months = sorted(by_month)
        amounts = [by_month[m] for m in months]
        ax.bar(months, amounts, color="#539ecd")
        ax.set_xlabel("Mois")
        ax.set_ylabel("Montant")
        ax.set_title("Achats par mois")
        self.figure.autofmt_xdate(rotation=45)
        self.canvas.draw()

    # Public API --------------------------------------------------------
    @Slot()
    def refresh(self) -> None:
        """Reload purchases from the database and update widgets."""
        rows = self._load_purchases()
        total, amount, avg, by_month = self._compute_metrics(rows)
        self._update_summary(total, amount, avg)
        self._update_chart(by_month)

===== MOTEUR/compta/db.py =====

from __future__ import annotations

import sqlite3
from pathlib import Path

MEM_URI = "file:memdb1?mode=memory&cache=shared"


def connect(db_path: Path | str) -> sqlite3.Connection:
    """Return a SQLite connection with foreign keys enabled."""
    db_str = str(db_path)
    if db_str == ":memory:":
        conn = sqlite3.connect(MEM_URI, uri=True)
    else:
        conn = sqlite3.connect(db_str, uri=db_str.startswith("file:"))
    conn.execute("PRAGMA foreign_keys = ON")
    conn.row_factory = sqlite3.Row
    return conn

===== MOTEUR/compta/models.py =====

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional


@dataclass
class Supplier:
    """Supplier information."""

    id: Optional[int]
    name: str
    vat_number: Optional[str] = None
    address: Optional[str] = None


@dataclass
class Purchase:
    """Purchase record."""

    id: Optional[int]
    date: str
    invoice_number: str
    supplier_id: int
    label: str
    ht_amount: float
    vat_amount: float
    vat_rate: float
    account_code: str
    due_date: str
    payment_status: str
    payment_date: Optional[str] = None
    payment_method: Optional[str] = None
    is_advance: int = 0
    is_invoice_received: int = 1
    attachment_path: Optional[str] = None
    created_by: Optional[str] = None
    updated_at: Optional[str] = None


@dataclass
class EntryLine:
    """Accounting entry line."""

    account: str
    debit: float = 0.0
    credit: float = 0.0
    description: Optional[str] = None


@dataclass
class PurchaseFilter:
    """Filters for querying purchases."""

    start: Optional[str] = None
    end: Optional[str] = None
    supplier_id: Optional[int] = None
    status: Optional[str] = None


@dataclass
class VatLine:
    """VAT summary line."""

    rate: float
    base: float
    vat: float

===== MOTEUR/compta/ventes/__init__.py =====


===== MOTEUR/compta/ventes/db.py =====

from __future__ import annotations

import sqlite3
from pathlib import Path
from typing import List, Tuple


def init_db(db_path: Path) -> None:
    """Create the sales table if it does not already exist."""
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS sales (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                label TEXT NOT NULL,
                amount REAL NOT NULL
            )
            """
        )
        conn.commit()


def add_sale(db_path: Path, date: str, label: str, amount: float) -> int:
    """Add a sale row and return its new id."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.execute(
            "INSERT INTO sales (date, label, amount) VALUES (?, ?, ?)",
            (date, label, amount),
        )
        conn.commit()
        return cursor.lastrowid


def update_sale(
    db_path: Path, sale_id: int, date: str, label: str, amount: float
) -> None:
    """Update a sale row identified by *sale_id*."""
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            (
                "UPDATE sales SET date = ?, label = ?, amount = ? "
                "WHERE id = ?"
            ),
            (date, label, amount, sale_id),
        )
        conn.commit()


def delete_sale(db_path: Path, sale_id: int) -> None:
    """Delete the sale row identified by *sale_id*."""
    with sqlite3.connect(db_path) as conn:
        conn.execute("DELETE FROM sales WHERE id = ?", (sale_id,))
        conn.commit()


def fetch_all_sales(db_path: Path) -> List[Tuple[int, str, str, float]]:
    """Return all sale rows."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.execute(
            "SELECT id, date, label, amount FROM sales ORDER BY date"
        )
        return cursor.fetchall()

===== MOTEUR/compta/ventes/widget.py =====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, QDate
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_sale,
    update_sale,
    delete_sale,
    fetch_all_sales,
)

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class VenteWidget(QWidget):
    """Widget pour la gestion des ventes."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form_layout.addWidget(self.date_edit)

        form_layout.addWidget(QLabel("Libell\u00e9:"))
        self.label_edit = QLineEdit()
        form_layout.addWidget(self.label_edit)

        form_layout.addWidget(QLabel("Montant:"))
        self.amount_spin = QDoubleSpinBox()
        self.amount_spin.setDecimals(2)
        self.amount_spin.setMaximum(1e9)
        form_layout.addWidget(self.amount_spin)

        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_sale)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_sale)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_sale)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Date",
            "Libell\u00e9",
            "Montant",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_sales()

    def get_selected_id(self) -> int | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.data(Qt.UserRole)

    @Slot()
    def add_sale(self) -> None:
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Vente",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        add_sale(db_path, date, label, amount)
        self.load_sales()

    @Slot()
    def edit_sale(self) -> None:
        sale_id = self.get_selected_id()
        if sale_id is None:
            QMessageBox.warning(
                self,
                "Vente",
                "S\u00e9lectionnez une vente",
            )
            return
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Vente",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        update_sale(db_path, sale_id, date, label, amount)
        self.load_sales()

    @Slot()
    def remove_sale(self) -> None:
        sale_id = self.get_selected_id()
        if sale_id is None:
            QMessageBox.warning(self, "Vente", "S\u00e9lectionnez une vente")
            return
        delete_sale(db_path, sale_id)
        self.load_sales()

    def load_sales(self) -> None:
        self.table.setRowCount(0)
        for sale_id, date, label, amount in fetch_all_sales(
            db_path
        ):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item_date = QTableWidgetItem(date)
            item_date.setData(Qt.UserRole, sale_id)
            self.table.setItem(row, 0, item_date)
            self.table.setItem(row, 1, QTableWidgetItem(label))
            self.table.setItem(row, 2, QTableWidgetItem(f"{amount:.2f}"))

    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_date = self.table.item(row, 0)
        item_label = self.table.item(row, 1)
        item_amount = self.table.item(row, 2)
        if item_date and item_label and item_amount:
            self.date_edit.setDate(
                QDate.fromString(item_date.text(), "yyyy-MM-dd")
            )
            self.label_edit.setText(item_label.text())
            self.amount_spin.setValue(float(item_amount.text()))


===== MOTEUR/compta/accounting/widget.py =====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, Signal
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_account,
    update_account,
    delete_account,
    fetch_accounts,
)

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class AccountWidget(QWidget):
    """Widget for simple account management."""

    accounts_updated = Signal()

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Numéro:"))
        self.code_edit = QLineEdit()
        form_layout.addWidget(self.code_edit)
        form_layout.addWidget(QLabel("Libellé:"))
        self.name_edit = QLineEdit()
        form_layout.addWidget(self.name_edit)
        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_account)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_account)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_account)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Numéro", "Libellé"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_accounts()

===== MOTEUR/compta/suppliers/supplier_services.py =====
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple

from ..db import connect

SQL_CREATE_VIEW = """
CREATE VIEW IF NOT EXISTS supplier_balance_v AS
SELECT s.id      AS supplier_id,
       s.name    AS supplier_name,
       ROUND(SUM(CASE WHEN el.debit>0 THEN el.debit ELSE -el.credit END),2) AS balance
FROM suppliers s
LEFT JOIN entries   e   ON e.ref IN (
      SELECT invoice_number FROM purchases WHERE supplier_id = s.id)
LEFT JOIN entry_lines el ON el.entry_id = e.id
WHERE el.account IN ('401','408','4091')
GROUP BY s.id;
"""


def init_view(db_path: Path | str) -> None:
    """Ensure :data:`supplier_balance_v` exists."""
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_VIEW)
        conn.commit()


def get_suppliers_with_balance(db_path: Path | str) -> List[Tuple[int, str, float]]:
    """Return supplier id, name and balance (debit minus credit)."""
    init_view(db_path)
    with connect(db_path) as conn:
        cur = conn.execute(
            "SELECT supplier_id, supplier_name, balance FROM supplier_balance_v ORDER BY supplier_name"
        )
        return [(r[0], r[1], r[2]) for r in cur.fetchall()]


@dataclass
class TransactionRow:
    date: str
    journal: str
    ref: str
    label: str
    debit: float
    credit: float
    balance: float


def get_supplier_transactions(db_path: Path | str, supplier_id: int) -> List[TransactionRow]:
    """Return accounting movements for *supplier_id* ordered by date."""
    init_view(db_path)
    query = (
        "SELECT e.date, e.journal, e.ref, e.memo, el.debit, el.credit "
        "FROM entries e JOIN entry_lines el ON el.entry_id=e.id "
        "WHERE el.account IN ('401','408','4091') "
        "AND e.ref IN (SELECT invoice_number FROM purchases WHERE supplier_id=?) "
        "ORDER BY e.date, e.id"
    )
    with connect(db_path) as conn:
        cur = conn.execute(query, (supplier_id,))
        rows = cur.fetchall()

    result: List[TransactionRow] = []
    balance = 0.0
    for date, journal, ref, memo, debit, credit in rows:
        balance += debit - credit
        result.append(
            TransactionRow(
                date=date,
                journal=journal,
                ref=ref,
                label=memo or "",
                debit=debit,
                credit=credit,
                balance=round(balance, 2),
            )
        )
    return result

===== MOTEUR/compta/suppliers/supplier_tab.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHBoxLayout,
)

from MOTEUR.compta.achats.signals import signals as achat_signals
from .supplier_services import (
    init_view,
    get_suppliers_with_balance,
)
from .supplier_transactions_dialog import SupplierTransactionsDialog

BASE_DIR = Path(__file__).resolve().parent.parent.parent
DB_PATH = BASE_DIR / "compta.db"


class SupplierTab(QWidget):
    """Tab showing suppliers and their balance."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_view(DB_PATH)

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Fournisseur", "Montant"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellDoubleClicked.connect(self.open_details)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        self.refresh_btn = QPushButton("Rafraîchir")
        self.refresh_btn.clicked.connect(self.refresh)
        btn_layout.addStretch()
        btn_layout.addWidget(self.refresh_btn)
        layout.addLayout(btn_layout)

        achat_signals.supplier_changed.connect(self.refresh)
        self.refresh()

    # ------------------------------------------------------------------
    @Slot()
    def refresh(self) -> None:
        self.table.setRowCount(0)
        for sid, name, balance in get_suppliers_with_balance(DB_PATH):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item = QTableWidgetItem(name)
            item.setData(Qt.UserRole, sid)
            self.table.setItem(row, 0, item)
            bal_item = QTableWidgetItem(f"{balance:.2f}")
            color = Qt.red if balance > 0 else Qt.darkGreen
            bal_item.setForeground(color)
            self.table.setItem(row, 1, bal_item)

    # ------------------------------------------------------------------
    @Slot(int, int)
    def open_details(self, row: int, column: int) -> None:  # noqa: D401
        item = self.table.item(row, 0)
        if not item:
            return
        sid = item.data(Qt.UserRole)
        name = item.text()
        dlg = SupplierTransactionsDialog(DB_PATH, sid, name, self)
        dlg.exec()

===== MOTEUR/compta/suppliers/supplier_transactions_dialog.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional
import csv

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QFileDialog,
    QHBoxLayout,
)

from .supplier_services import get_supplier_transactions, TransactionRow

BASE_DIR = Path(__file__).resolve().parent.parent.parent
DB_PATH = BASE_DIR / "compta.db"


class SupplierTransactionsDialog(QDialog):
    """Display all accounting movements for a supplier."""

    def __init__(self, db_path: Path | str, supplier_id: int, name: str, parent: Optional[QDialog] = None) -> None:
        super().__init__(parent)
        self.db_path = db_path
        self.supplier_id = supplier_id
        self.setWindowTitle(f"Mouvements – {name}")

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([
            "Date",
            "Journal",
            "Pièce",
            "Libellé",
            "Débit",
            "Crédit",
            "Solde",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        export_btn = QPushButton("Exporter CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addStretch()
        btn_layout.addWidget(export_btn)
        layout.addLayout(btn_layout)

        self.load_transactions()

    # ------------------------------------------------------------------
    def load_transactions(self) -> None:
        rows = get_supplier_transactions(self.db_path, self.supplier_id)
        self.table.setRowCount(0)
        for r in rows:
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(r.date))
            self.table.setItem(row, 1, QTableWidgetItem(r.journal))
            self.table.setItem(row, 2, QTableWidgetItem(r.ref))
            self.table.setItem(row, 3, QTableWidgetItem(r.label))
            self.table.setItem(row, 4, QTableWidgetItem(f"{r.debit:.2f}"))
            self.table.setItem(row, 5, QTableWidgetItem(f"{r.credit:.2f}"))
            self.table.setItem(row, 6, QTableWidgetItem(f"{r.balance:.2f}"))

    # ------------------------------------------------------------------
    def export_csv(self) -> None:
        path, _ = QFileDialog.getSaveFileName(self, "Exporter CSV", str(Path.home()), "CSV (*.csv)")
        if not path:
            return
        rows = get_supplier_transactions(self.db_path, self.supplier_id)
        with open(path, "w", newline="", encoding="utf-8") as fh:
            writer = csv.writer(fh)
            writer.writerow(["Date", "Journal", "Pièce", "Libellé", "Débit", "Crédit", "Solde"])
            for r in rows:
                writer.writerow([r.date, r.journal, r.ref, r.label, f"{r.debit:.2f}", f"{r.credit:.2f}", f"{r.balance:.2f}"])


# ====== Revision services ======
SQL_CREATE_VIEW = """
CREATE VIEW IF NOT EXISTS account_balance_v AS
SELECT a.code AS account_code,
       a.name AS account_name,
       ROUND(SUM(el.debit - el.credit),2) AS balance
FROM accounts a
LEFT JOIN entry_lines el ON el.account = a.code
GROUP BY a.code;
"""
SQL_IDX_ENTRY_LINES_ACC = "CREATE INDEX IF NOT EXISTS idx_el_account ON entry_lines(account)"
SQL_IDX_ENTRIES_REF = "CREATE INDEX IF NOT EXISTS idx_entries_ref  ON entries(ref)"

def init_view(db_path: Path | str) -> None:
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_VIEW)
        conn.execute(SQL_IDX_ENTRY_LINES_ACC)
        conn.execute(SQL_IDX_ENTRIES_REF)
        conn.commit()

def get_accounts_with_balance(db_path: Path | str) -> List[Tuple[str, str, float]]:
    init_view(db_path)
    with connect(db_path) as conn:
        cur = conn.execute("SELECT account_code, account_name, balance FROM account_balance_v ORDER BY account_code")
        return [(r[0], r[1], r[2]) for r in cur.fetchall()]

@dataclass
class AccTransaction:
    date: str
    journal: str
    ref: str
    label: str
    debit: float
    credit: float
    balance: float

def get_account_transactions(db_path: Path | str, code: str) -> List[AccTransaction]:
    init_view(db_path)
    sql = (
        "SELECT e.date, e.journal, e.ref, e.memo, el.debit, el.credit "
        "FROM entries e JOIN entry_lines el ON el.entry_id = e.id "
        "WHERE el.account = ? ORDER BY e.date, e.id"
    )
    with connect(db_path) as conn:
        rows = conn.execute(sql, (code,)).fetchall()
    bal = 0.0
    out: List[AccTransaction] = []
    for d, j, r, m, de, cr in rows:
        bal += de - cr
        out.append(AccTransaction(d, j, r, m or "", de, cr, round(bal, 2)))
    return out


# ====== Revision tab ======
class RevisionTab(QWidget):
    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_view(DB_PATH)
        layout = QVBoxLayout(self)
        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["Compte", "Intitulé", "Solde N"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellDoubleClicked.connect(self.show_details)
        layout.addWidget(self.table)
        btn_row = QHBoxLayout()
        refresh = QPushButton("Rafraîchir")
        refresh.clicked.connect(self.refresh)
        btn_row.addStretch(); btn_row.addWidget(refresh)
        layout.addLayout(btn_row)
        achat_signals.entry_changed.connect(self.refresh)
        self.refresh()

    @Slot()
    def refresh(self) -> None:
        self.table.setRowCount(0)
        for code, name, bal in get_accounts_with_balance(DB_PATH):
            r = self.table.rowCount(); self.table.insertRow(r)
            item = QTableWidgetItem(code); item.setData(Qt.UserRole, code)
            self.table.setItem(r, 0, item)
            self.table.setItem(r, 1, QTableWidgetItem(name))
            bal_item = QTableWidgetItem(f"{bal:.2f}")
            bal_item.setForeground(Qt.darkGreen if bal > 0 else Qt.red)
            self.table.setItem(r, 2, bal_item)

    @Slot(int, int)
    def show_details(self, row: int, col: int) -> None:
        item = self.table.item(row, 0)
        if not item:
            return
        code = item.data(Qt.UserRole)
        name = self.table.item(row, 1).text()
        dlg = AccountTransactionsDialog(DB_PATH, code, name, self)
        dlg.exec()


# ====== AccountTransactionsDialog ======
class AccountTransactionsDialog(QDialog):
    def __init__(self, db: Path | str, code: str, name: str, parent: Optional[QDialog] = None):
        super().__init__(parent)
        self.db = db; self.code = code
        self.setWindowTitle(f"Mouvements – {code} {name}")
        lay = QVBoxLayout(self)
        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels(["Date", "Journal", "Pièce", "Libellé", "Débit", "Crédit", "Solde"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        lay.addWidget(self.table)
        btn = QPushButton("Exporter CSV"); btn.clicked.connect(self.export_csv)
        h = QHBoxLayout(); h.addStretch(); h.addWidget(btn); lay.addLayout(h)
        self.load()

    def load(self):
        rows = get_account_transactions(self.db, self.code)
        self.table.setRowCount(0)
        for r in rows:
            i = self.table.rowCount(); self.table.insertRow(i)
            self.table.setItem(i, 0, QTableWidgetItem(r.date))
            self.table.setItem(i, 1, QTableWidgetItem(r.journal))
            self.table.setItem(i, 2, QTableWidgetItem(r.ref))
            self.table.setItem(i, 3, QTableWidgetItem(r.label))
            self.table.setItem(i, 4, QTableWidgetItem(f"{r.debit:.2f}"))
            self.table.setItem(i, 5, QTableWidgetItem(f"{r.credit:.2f}"))
            self.table.setItem(i, 6, QTableWidgetItem(f"{r.balance:.2f}"))

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Exporter CSV", str(Path.home()), "CSV (*.csv)")
        if not path:
            return
        rows = get_account_transactions(self.db, self.code)
        with open(path, "w", newline="", encoding="utf-8") as fh:
            writer = csv.writer(fh)
            writer.writerow(["Date", "Journal", "Pièce", "Libellé", "Débit", "Crédit", "Solde"])
            for r in rows:
                writer.writerow([r.date, r.journal, r.ref, r.label, f"{r.debit:.2f}", f"{r.credit:.2f}", f"{r.balance:.2f}"])

===== MOTEUR/compta/dashboard/__init__.py =====

===== MOTEUR/compta/dashboard/config.json =====
{
  "show_total_count": true,
  "show_total_amount": true,
  "show_avg_per_month": true,
  "show_chart": true
}

===== MOTEUR/compta/dashboard/widget.py =====
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Optional
import json

from PySide6.QtCore import Slot, Signal
from PySide6.QtWidgets import (
    QLabel,
    QVBoxLayout,
    QWidget,
    QCheckBox,
    QHBoxLayout,
    QPushButton,
)

from ..achats.db import fetch_all_purchases, init_db

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database used in AchatWidget
DB_PATH = BASE_DIR / "compta.db"
CONFIG_PATH = Path(__file__).with_name("config.json")

DEFAULT_CONFIG = {
    "show_total_count": True,
    "show_total_amount": True,
    "show_avg_per_month": True,
    "show_chart": True,
}

try:
    import matplotlib

    matplotlib.use("QtAgg")  # Use Qt backend for PySide6
    from matplotlib.backends.backend_qtagg import (
        FigureCanvasQTAgg as FigureCanvas,
    )
    from matplotlib.figure import Figure

    MPL_AVAILABLE = True
except Exception:  # pragma: no cover - matplotlib is optional
    MPL_AVAILABLE = False


def load_dashboard_config() -> dict:
    """Return dashboard configuration from :data:`CONFIG_PATH`."""
    if CONFIG_PATH.exists():
        try:
            with CONFIG_PATH.open("r", encoding="utf-8") as fh:
                data = json.load(fh)
            return {**DEFAULT_CONFIG, **{k: bool(v) for k, v in data.items()}}
        except Exception:
            return DEFAULT_CONFIG.copy()
    CONFIG_PATH.write_text(
        json.dumps(DEFAULT_CONFIG, indent=2, ensure_ascii=False)
    )
    return DEFAULT_CONFIG.copy()


def save_dashboard_config(config: dict) -> None:
    """Write *config* to :data:`CONFIG_PATH`."""
    with CONFIG_PATH.open("w", encoding="utf-8") as fh:
        json.dump(config, fh, ensure_ascii=False, indent=2)


def build_summary_text(
    total: int,
    amount: float,
    avg: float,
    config: dict,
) -> str:
    """Return summary text based on *config*."""
    lines: list[str] = []
    if config.get("show_total_count", True):
        lines.append(f"Nombre d'achats : {total}")
    if config.get("show_total_amount", True):
        lines.append(f"Total : {amount:.2f} \u20ac")
    if config.get("show_avg_per_month", True):
        lines.append(f"Moyenne par mois : {avg:.2f} \u20ac")
    return "\n".join(lines)


class DashboardWidget(QWidget):
    """Widget displaying purchase statistics with an optional graph."""

    journal_requested = Signal()
    grand_livre_requested = Signal()
    scraping_summary_requested = Signal()

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(DB_PATH)

        self.config = load_dashboard_config()

        layout = QVBoxLayout(self)

        nav_layout = QHBoxLayout()
        journal_btn = QPushButton("Journal")
        journal_btn.clicked.connect(self.journal_requested.emit)
        nav_layout.addWidget(journal_btn)

        grand_btn = QPushButton("Grand Livre")
        grand_btn.clicked.connect(self.grand_livre_requested.emit)
        nav_layout.addWidget(grand_btn)

        scrap_btn = QPushButton("Dernier scraping")
        scrap_btn.clicked.connect(self.scraping_summary_requested.emit)
        nav_layout.addWidget(scrap_btn)
        layout.addLayout(nav_layout)

        self.summary_label = QLabel()
        layout.addWidget(self.summary_label)

        if MPL_AVAILABLE:
            self.figure = Figure(figsize=(5, 3))
            self.canvas = FigureCanvas(self.figure)
            layout.addWidget(self.canvas)
        else:  # pragma: no cover - depends on matplotlib being installed
            self.figure = None
            self.canvas = None
            layout.addWidget(
                QLabel("matplotlib requis pour l'affichage du graphique")
            )

        config_layout = QHBoxLayout()
        self.count_cb = QCheckBox("Nombre")
        self.amount_cb = QCheckBox("Total")
        self.avg_cb = QCheckBox("Moyenne/mois")
        self.chart_cb = QCheckBox("Graphique")
        for key, cb in [
            ("show_total_count", self.count_cb),
            ("show_total_amount", self.amount_cb),
            ("show_avg_per_month", self.avg_cb),
            ("show_chart", self.chart_cb),
        ]:
            cb.setChecked(self.config.get(key, True))
            cb.stateChanged.connect(self._config_changed)
            config_layout.addWidget(cb)
        layout.addLayout(config_layout)

        self.refresh()

    # ------------------------------------------------------------------
    @Slot()
    def _config_changed(self) -> None:
        """Persist config and refresh widgets when checkboxes change."""
        self.config = {
            "show_total_count": self.count_cb.isChecked(),
            "show_total_amount": self.amount_cb.isChecked(),
            "show_avg_per_month": self.avg_cb.isChecked(),
            "show_chart": self.chart_cb.isChecked(),
        }
        save_dashboard_config(self.config)
        self.refresh()

    # ------------------------------------------------------------------
    def _load_purchases(self) -> list[tuple[int, str, str, float, str, str]]:
        return fetch_all_purchases(DB_PATH)

    def _compute_metrics(self, rows: list[tuple[int, str, str, float, str, str]]):
        total_count = len(rows)
        total_amount = sum(r[3] for r in rows)

        by_month: dict[str, float] = defaultdict(float)
        for _pid, date_str, _label, amount, *_ in rows:
            try:
                dt = datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                continue
            key = dt.strftime("%Y-%m")
            by_month[key] += amount
        avg_per_month = total_amount / len(by_month) if by_month else 0.0
        return total_count, total_amount, avg_per_month, by_month

    def _update_summary(self, total: int, amount: float, avg: float) -> None:
        text = build_summary_text(total, amount, avg, self.config)
        self.summary_label.setText(text)
        self.summary_label.setVisible(bool(text))

    def _update_chart(self, by_month: dict[str, float]) -> None:
        if not MPL_AVAILABLE or not self.figure:
            return
        if not self.config.get("show_chart", True):
            if self.canvas:
                self.canvas.hide()
            return
        if self.canvas:
            self.canvas.show()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        months = sorted(by_month)
        amounts = [by_month[m] for m in months]
        ax.bar(months, amounts, color="#539ecd")
        ax.set_xlabel("Mois")
        ax.set_ylabel("Montant")
        ax.set_title("Achats par mois")
        self.figure.autofmt_xdate(rotation=45)
        self.canvas.draw()

    # Public API --------------------------------------------------------
    @Slot()
    def refresh(self) -> None:
        """Reload purchases from the database and update widgets."""
        rows = self._load_purchases()
        total, amount, avg, by_month = self._compute_metrics(rows)
        self._update_summary(total, amount, avg)
        self._update_chart(by_month)

===== MOTEUR/compta/db.py =====
from __future__ import annotations

import sqlite3
from pathlib import Path

MEM_URI = "file:memdb1?mode=memory&cache=shared"


def connect(db_path: Path | str) -> sqlite3.Connection:
    """Return a SQLite connection with foreign keys enabled."""
    db_str = str(db_path)
    if db_str == ":memory:":
        conn = sqlite3.connect(MEM_URI, uri=True)
    else:
        conn = sqlite3.connect(db_str, uri=db_str.startswith("file:"))
    conn.execute("PRAGMA foreign_keys = ON")
    conn.row_factory = sqlite3.Row
    return conn

===== MOTEUR/compta/models.py =====
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional


@dataclass
class Supplier:
    """Supplier information."""

    id: Optional[int]
    name: str
    vat_number: Optional[str] = None
    address: Optional[str] = None


@dataclass
class Purchase:
    """Purchase record.

    The model originally stored the HT and VAT amounts as well as an
    ``invoice_number``.  The revamped UI now works with the total amount
    including VAT (TTC) and an internal reference called ``piece``.
    ``ht_amount`` and ``vat_amount`` are therefore computed when needed and are
    no longer part of the public API.
    """

    id: Optional[int]
    date: str
    piece: str
    supplier_id: int
    label: str
    ttc_amount: float
    vat_rate: float
    account_code: str
    due_date: str
    payment_status: str
    payment_date: Optional[str] = None
    payment_method: Optional[str] = None
    is_advance: int = 0
    is_invoice_received: int = 1
    attachment_path: Optional[str] = None
    created_by: Optional[str] = None
    updated_at: Optional[str] = None


@dataclass
class EntryLine:
    """Accounting entry line."""

    account: str
    debit: float = 0.0
    credit: float = 0.0
    description: Optional[str] = None


@dataclass
class PurchaseFilter:
    """Filters for querying purchases."""

    start: Optional[str] = None
    end: Optional[str] = None
    supplier_id: Optional[int] = None
    status: Optional[str] = None


@dataclass
class VatLine:
    """VAT summary line."""

    rate: float
    base: float
    vat: float

===== MOTEUR/compta/parameters/__init__.py =====
from .journals_widget import JournalsWidget

__all__ = ["JournalsWidget"]

===== MOTEUR/compta/parameters/journals_widget.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from ..accounting.db import (
    init_db,
    add_journal,
    update_journal,
    delete_journal,
    fetch_journals,
)

BASE_DIR = Path(__file__).resolve().parent.parent.parent
DB_PATH = BASE_DIR / "compta.db"


class JournalsWidget(QWidget):
    """Simple CRUD widget for accounting journals."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(DB_PATH)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Code:"))
        self.code_edit = QLineEdit()
        form_layout.addWidget(self.code_edit)
        form_layout.addWidget(QLabel("Libellé:"))
        self.name_edit = QLineEdit()
        form_layout.addWidget(self.name_edit)
        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_journal)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_journal)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_journal)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Code", "Libellé"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_journals()

    # ------------------------------------------------------------------
    def get_selected_code(self) -> str | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.text()

    # ------------------------------------------------------------------
    def load_journals(self) -> None:
        self.table.setRowCount(0)
        for code, name in fetch_journals(DB_PATH):
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(code))
            self.table.setItem(row, 1, QTableWidgetItem(name))
        self.code_edit.clear()
        self.name_edit.clear()

    # ------------------------------------------------------------------
    @Slot()
    def add_journal(self) -> None:
        code = self.code_edit.text().strip()
        name = self.name_edit.text().strip()
        if not code or not name:
            QMessageBox.warning(self, "Journal", "Code ou libellé manquant")
            return
        add_journal(DB_PATH, code, name)
        self.load_journals()

    # ------------------------------------------------------------------
    @Slot()
    def edit_journal(self) -> None:
        code = self.get_selected_code()
        if code is None:
            QMessageBox.warning(self, "Journal", "Sélectionnez un journal")
            return
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Journal", "Libellé manquant")
            return
        update_journal(DB_PATH, code, name)
        self.load_journals()

    # ------------------------------------------------------------------
    @Slot()
    def remove_journal(self) -> None:
        code = self.get_selected_code()
        if code is None:
            QMessageBox.warning(self, "Journal", "Sélectionnez un journal")
            return
        delete_journal(DB_PATH, code)
        self.load_journals()

    # ------------------------------------------------------------------
    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_code = self.table.item(row, 0)
        item_name = self.table.item(row, 1)
        if item_code and item_name:
            self.code_edit.setText(item_code.text())
            self.name_edit.setText(item_name.text())


===== MOTEUR/compta/revision/__init__.py =====
from .revision_tab import RevisionTab
from .revision_services import (
    get_accounts_with_balance,
    get_account_transactions,
    init_view,
    AccTransaction,
)
from .transactions_dialog import AccountTransactionsDialog

__all__ = [
    "RevisionTab",
    "get_accounts_with_balance",
    "get_account_transactions",
    "init_view",
    "AccTransaction",
    "AccountTransactionsDialog",
]

===== MOTEUR/compta/revision/revision_services.py =====
from __future__ import annotations
from pathlib import Path
from typing import List, Tuple
from dataclasses import dataclass

from ..db import connect

# --------------------------------------------------
SQL_CREATE_VIEW = """
CREATE VIEW IF NOT EXISTS account_balance_v AS
SELECT a.code                  AS account_code,
       a.name                  AS account_name,
       ROUND(IFNULL(SUM(el.debit - el.credit), 0), 2) AS balance
FROM   accounts a
LEFT JOIN entry_lines el ON el.account = a.code
GROUP BY a.code;
"""
SQL_IDX_ENTRY_LINES_ACC = "CREATE INDEX IF NOT EXISTS idx_el_account ON entry_lines(account)"
SQL_IDX_ENTRIES_REF     = "CREATE INDEX IF NOT EXISTS idx_entries_ref  ON entries(ref)"

# --------------------------------------------------
def init_view(db_path: Path | str) -> None:
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_VIEW)
        conn.execute(SQL_IDX_ENTRY_LINES_ACC)
        conn.execute(SQL_IDX_ENTRIES_REF)
        conn.commit()

# --------------------------------------------------
def get_accounts_with_balance(db_path: Path | str) -> List[Tuple[str,str,float]]:
    """Retourne (code, name, balance) trié par code."""
    init_view(db_path)
    with connect(db_path) as conn:
        cur = conn.execute("SELECT account_code, account_name, balance FROM account_balance_v ORDER BY account_code")
        return [(r[0], r[1], r[2]) for r in cur.fetchall()]

# --------------------------------------------------
@dataclass
class AccTransaction:
    date: str
    journal: str
    ref: str
    label: str
    debit: float
    credit: float
    balance: float

# --------------------------------------------------
def get_account_transactions(db_path: Path | str, code: str) -> List[AccTransaction]:
    init_view(db_path)
    sql = (
        "SELECT e.date, e.journal, e.ref, e.memo, el.debit, el.credit "
        "FROM entries e JOIN entry_lines el ON el.entry_id = e.id "
        "WHERE el.account = ? ORDER BY e.date, e.id"
    )
    with connect(db_path) as conn:
        rows = conn.execute(sql, (code,)).fetchall()
    bal = 0.0
    out: List[AccTransaction] = []
    for d,j,r,m,de,cr in rows:
        bal += de - cr
        out.append(AccTransaction(d,j,r,m or "",de,cr,round(bal,2)))
    return out

===== MOTEUR/compta/revision/revision_tab.py =====
from __future__ import annotations
from pathlib import Path
from typing import Optional
from PySide6.QtCore import Qt, Slot
from PySide6.QtWidgets import QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton, QHBoxLayout

from ..achats.signals import signals as achat_signals
from .revision_services import init_view, get_accounts_with_balance
from .transactions_dialog import AccountTransactionsDialog

BASE_DIR = Path(__file__).resolve().parent.parent.parent
DB_PATH  = BASE_DIR / "compta.db"

class RevisionTab(QWidget):
    """Balance générale dynamique."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_view(DB_PATH)
        layout = QVBoxLayout(self)
        self.table = QTableWidget(0,3)
        self.table.setHorizontalHeaderLabels(["Compte","Intitulé","Solde N"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellDoubleClicked.connect(self.show_details)
        layout.addWidget(self.table)

        btn_row = QHBoxLayout()
        refresh = QPushButton("Rafraîchir")
        refresh.clicked.connect(self.refresh)
        btn_row.addStretch(); btn_row.addWidget(refresh)
        layout.addLayout(btn_row)

        achat_signals.entry_changed.connect(self.refresh)
        self.refresh()

    # ------------------------------------------------
    @Slot()
    def refresh(self) -> None:
        self.table.setRowCount(0)
        for code, name, bal in get_accounts_with_balance(DB_PATH):
            r = self.table.rowCount()
            self.table.insertRow(r)
            item = QTableWidgetItem(code)
            item.setData(Qt.UserRole, code)
            self.table.setItem(r, 0, item)
            self.table.setItem(r, 1, QTableWidgetItem(name))
            # `bal` might be ``None`` if the SQL view returns NULL.
            # Guard against it before formatting.
            bal = bal if bal is not None else 0.0
            bal_item = QTableWidgetItem(f"{bal:.2f}")
            bal_item.setForeground(Qt.darkGreen if bal > 0 else Qt.red)
            self.table.setItem(r, 2, bal_item)

    # ------------------------------------------------
    @Slot(int,int)
    def show_details(self,row:int,col:int)->None:
        item = self.table.item(row,0)
        if not item: return
        code = item.data(Qt.UserRole)
        name = self.table.item(row,1).text()
        dlg  = AccountTransactionsDialog(DB_PATH, code, name, self)
        dlg.exec()

===== MOTEUR/compta/revision/transactions_dialog.py =====
from __future__ import annotations
from pathlib import Path
from typing import Optional
import csv
from PySide6.QtWidgets import QDialog, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton, QFileDialog, QHBoxLayout
from .revision_services import get_account_transactions

class AccountTransactionsDialog(QDialog):
    def __init__(self, db: Path|str, code: str, name: str, parent: Optional[QDialog]=None):
        super().__init__(parent)
        self.db=db; self.code=code
        self.setWindowTitle(f"Mouvements – {code} {name}")
        lay = QVBoxLayout(self)
        self.table = QTableWidget(0,7)
        self.table.setHorizontalHeaderLabels(["Date","Journal","Pièce","Libellé","Débit","Crédit","Solde"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        lay.addWidget(self.table)
        btn = QPushButton("Exporter CSV"); btn.clicked.connect(self.export_csv)
        h = QHBoxLayout(); h.addStretch(); h.addWidget(btn); lay.addLayout(h)
        self.load()

    def load(self):
        rows = get_account_transactions(self.db,self.code)
        self.table.setRowCount(0)
        for r in rows:
            i=self.table.rowCount(); self.table.insertRow(i)
            self.table.setItem(i,0,QTableWidgetItem(r.date))
            self.table.setItem(i,1,QTableWidgetItem(r.journal))
            self.table.setItem(i,2,QTableWidgetItem(r.ref))
            self.table.setItem(i,3,QTableWidgetItem(r.label))
            self.table.setItem(i,4,QTableWidgetItem(f"{r.debit:.2f}"))
            self.table.setItem(i,5,QTableWidgetItem(f"{r.credit:.2f}"))
            self.table.setItem(i,6,QTableWidgetItem(f"{r.balance:.2f}"))

    def export_csv(self):
        path,_=QFileDialog.getSaveFileName(self,"Exporter CSV",str(Path.home()),"CSV (*.csv)")
        if not path: return
        rows = get_account_transactions(self.db,self.code)
        with open(path,"w",newline="",encoding="utf-8") as fh:
            w=csv.writer(fh); w.writerow(["Date","Journal","Pièce","Libellé","Débit","Crédit","Solde"])
            for r in rows:
                w.writerow([r.date,r.journal,r.ref,r.label,f"{r.debit:.2f}",f"{r.credit:.2f}",f"{r.balance:.2f}"])

===== MOTEUR/compta/suppliers/__init__.py =====
from .supplier_tab import SupplierTab
from .supplier_services import (
    get_suppliers_with_balance,
    get_supplier_transactions,
    init_view,
    TransactionRow,
)
from .supplier_transactions_dialog import SupplierTransactionsDialog

__all__ = [
    "SupplierTab",
    "get_suppliers_with_balance",
    "get_supplier_transactions",
    "init_view",
    "TransactionRow",
    "SupplierTransactionsDialog",
]

===== MOTEUR/compta/suppliers/supplier_services.py =====
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple

from ..db import connect

SQL_CREATE_VIEW = """
CREATE VIEW IF NOT EXISTS supplier_balance_v AS
SELECT s.id      AS supplier_id,
       s.name    AS supplier_name,
       ROUND(COALESCE(SUM(CASE WHEN el.debit>0 THEN el.debit ELSE -el.credit END), 0), 2) AS balance
FROM suppliers s
LEFT JOIN entries   e   ON e.ref IN (
      SELECT piece FROM purchases WHERE supplier_id = s.id)
LEFT JOIN entry_lines el ON el.entry_id = e.id
WHERE el.account IN ('401','408','4091')
GROUP BY s.id;
"""


def init_view(db_path: Path | str) -> None:
    """Ensure :data:`supplier_balance_v` exists."""
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_VIEW)
        conn.commit()


def get_suppliers_with_balance(db_path: Path | str) -> List[Tuple[int, str, float]]:
    """Return supplier id, name and balance (debit minus credit)."""
    init_view(db_path)
    with connect(db_path) as conn:
        cur = conn.execute(
            "SELECT supplier_id, supplier_name, balance FROM supplier_balance_v ORDER BY supplier_name"
        )
        return [(r[0], r[1], r[2]) for r in cur.fetchall()]


@dataclass
class TransactionRow:
    date: str
    journal: str
    ref: str
    label: str
    debit: float
    credit: float
    balance: float


def get_supplier_transactions(db_path: Path | str, supplier_id: int) -> List[TransactionRow]:
    """Return accounting movements for *supplier_id* ordered by date."""
    init_view(db_path)
    query = (
        "SELECT e.date, e.journal, e.ref, e.memo, el.debit, el.credit "
        "FROM entries e JOIN entry_lines el ON el.entry_id=e.id "
        "WHERE el.account IN ('401','408','4091') "
        "AND e.ref IN (SELECT piece FROM purchases WHERE supplier_id=?) "
        "ORDER BY e.date, e.id"
    )
    with connect(db_path) as conn:
        cur = conn.execute(query, (supplier_id,))
        rows = cur.fetchall()

    result: List[TransactionRow] = []
    balance = 0.0
    for date, journal, ref, memo, debit, credit in rows:
        balance += debit - credit
        result.append(
            TransactionRow(
                date=date,
                journal=journal,
                ref=ref,
                label=memo or "",
                debit=debit,
                credit=credit,
                balance=round(balance, 2),
            )
        )
    return result

===== MOTEUR/compta/suppliers/supplier_tab.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHBoxLayout,
)

from MOTEUR.compta.achats.signals import signals as achat_signals
from .supplier_services import (
    init_view,
    get_suppliers_with_balance,
)
from .supplier_transactions_dialog import SupplierTransactionsDialog

BASE_DIR = Path(__file__).resolve().parent.parent.parent
DB_PATH = BASE_DIR / "compta.db"


class SupplierTab(QWidget):
    """Tab showing suppliers and their balance."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_view(DB_PATH)

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Fournisseur", "Montant"])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellDoubleClicked.connect(self.open_details)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        self.refresh_btn = QPushButton("Rafraîchir")
        self.refresh_btn.clicked.connect(self.refresh)
        btn_layout.addStretch()
        btn_layout.addWidget(self.refresh_btn)
        layout.addLayout(btn_layout)

        achat_signals.supplier_changed.connect(self.refresh)
        self.refresh()

    # ------------------------------------------------------------------
    @Slot()
    def refresh(self) -> None:
        self.table.setRowCount(0)
        for sid, name, balance in get_suppliers_with_balance(DB_PATH):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item = QTableWidgetItem(name)
            item.setData(Qt.UserRole, sid)
            self.table.setItem(row, 0, item)
            bal_item = QTableWidgetItem(f"{balance:.2f}")
            color = Qt.red if balance > 0 else Qt.darkGreen
            bal_item.setForeground(color)
            self.table.setItem(row, 1, bal_item)

    # ------------------------------------------------------------------
    @Slot(int, int)
    def open_details(self, row: int, column: int) -> None:  # noqa: D401
        item = self.table.item(row, 0)
        if not item:
            return
        sid = item.data(Qt.UserRole)
        name = item.text()
        dlg = SupplierTransactionsDialog(DB_PATH, sid, name, self)
        dlg.exec()

===== MOTEUR/compta/suppliers/supplier_transactions_dialog.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional
import csv

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QFileDialog,
    QHBoxLayout,
)

from .supplier_services import get_supplier_transactions, TransactionRow

BASE_DIR = Path(__file__).resolve().parent.parent.parent
DB_PATH = BASE_DIR / "compta.db"


class SupplierTransactionsDialog(QDialog):
    """Display all accounting movements for a supplier."""

    def __init__(self, db_path: Path | str, supplier_id: int, name: str, parent: Optional[QDialog] = None) -> None:
        super().__init__(parent)
        self.db_path = db_path
        self.supplier_id = supplier_id
        self.setWindowTitle(f"Mouvements – {name}")

        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([
            "Date",
            "Journal",
            "Pièce",
            "Libellé",
            "Débit",
            "Crédit",
            "Solde",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        layout.addWidget(self.table)

        btn_layout = QHBoxLayout()
        export_btn = QPushButton("Exporter CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_layout.addStretch()
        btn_layout.addWidget(export_btn)
        layout.addLayout(btn_layout)

        self.load_transactions()

    # ------------------------------------------------------------------
    def load_transactions(self) -> None:
        rows = get_supplier_transactions(self.db_path, self.supplier_id)
        self.table.setRowCount(0)
        for r in rows:
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(r.date))
            self.table.setItem(row, 1, QTableWidgetItem(r.journal))
            self.table.setItem(row, 2, QTableWidgetItem(r.ref))
            self.table.setItem(row, 3, QTableWidgetItem(r.label))
            self.table.setItem(row, 4, QTableWidgetItem(f"{r.debit:.2f}"))
            self.table.setItem(row, 5, QTableWidgetItem(f"{r.credit:.2f}"))
            self.table.setItem(row, 6, QTableWidgetItem(f"{r.balance:.2f}"))

    # ------------------------------------------------------------------
    def export_csv(self) -> None:
        path, _ = QFileDialog.getSaveFileName(self, "Exporter CSV", str(Path.home()), "CSV (*.csv)")
        if not path:
            return
        rows = get_supplier_transactions(self.db_path, self.supplier_id)
        with open(path, "w", newline="", encoding="utf-8") as fh:
            writer = csv.writer(fh)
            writer.writerow(["Date", "Journal", "Pièce", "Libellé", "Débit", "Crédit", "Solde"])
            for r in rows:
                writer.writerow([r.date, r.journal, r.ref, r.label, f"{r.debit:.2f}", f"{r.credit:.2f}", f"{r.balance:.2f}"])

===== MOTEUR/compta/ventes/__init__.py =====

===== MOTEUR/compta/ventes/db.py =====
from __future__ import annotations

import sqlite3
from pathlib import Path
from typing import List, Tuple


def init_db(db_path: Path) -> None:
    """Create the sales table if it does not already exist."""
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS sales (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                label TEXT NOT NULL,
                amount REAL NOT NULL
            )
            """
        )
        conn.commit()


def add_sale(db_path: Path, date: str, label: str, amount: float) -> int:
    """Add a sale row and return its new id."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.execute(
            "INSERT INTO sales (date, label, amount) VALUES (?, ?, ?)",
            (date, label, amount),
        )
        conn.commit()
        return cursor.lastrowid


def update_sale(
    db_path: Path, sale_id: int, date: str, label: str, amount: float
) -> None:
    """Update a sale row identified by *sale_id*."""
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            (
                "UPDATE sales SET date = ?, label = ?, amount = ? "
                "WHERE id = ?"
            ),
            (date, label, amount, sale_id),
        )
        conn.commit()


def delete_sale(db_path: Path, sale_id: int) -> None:
    """Delete the sale row identified by *sale_id*."""
    with sqlite3.connect(db_path) as conn:
        conn.execute("DELETE FROM sales WHERE id = ?", (sale_id,))
        conn.commit()


def fetch_all_sales(db_path: Path) -> List[Tuple[int, str, str, float]]:
    """Return all sale rows."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.execute(
            "SELECT id, date, label, amount FROM sales ORDER BY date"
        )
        return cursor.fetchall()

===== MOTEUR/compta/ventes/widget.py =====
from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, QDate
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_sale,
    update_sale,
    delete_sale,
    fetch_all_sales,
)

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class VenteWidget(QWidget):
    """Widget pour la gestion des ventes."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form_layout.addWidget(self.date_edit)

        form_layout.addWidget(QLabel("Libell\u00e9:"))
        self.label_edit = QLineEdit()
        form_layout.addWidget(self.label_edit)

        form_layout.addWidget(QLabel("Montant:"))
        self.amount_spin = QDoubleSpinBox()
        self.amount_spin.setDecimals(2)
        self.amount_spin.setMaximum(1e9)
        form_layout.addWidget(self.amount_spin)

        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_sale)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_sale)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_sale)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Date",
            "Libell\u00e9",
            "Montant",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_sales()

    def get_selected_id(self) -> int | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.data(Qt.UserRole)

    @Slot()
    def add_sale(self) -> None:
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Vente",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        add_sale(db_path, date, label, amount)
        self.load_sales()

    @Slot()
    def edit_sale(self) -> None:
        sale_id = self.get_selected_id()
        if sale_id is None:
            QMessageBox.warning(
                self,
                "Vente",
                "S\u00e9lectionnez une vente",
            )
            return
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Vente",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        update_sale(db_path, sale_id, date, label, amount)
        self.load_sales()

    @Slot()
    def remove_sale(self) -> None:
        sale_id = self.get_selected_id()
        if sale_id is None:
            QMessageBox.warning(self, "Vente", "S\u00e9lectionnez une vente")
            return
        delete_sale(db_path, sale_id)
        self.load_sales()

    def load_sales(self) -> None:
        self.table.setRowCount(0)
        for sale_id, date, label, amount in fetch_all_sales(
            db_path
        ):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item_date = QTableWidgetItem(date)
            item_date.setData(Qt.UserRole, sale_id)
            self.table.setItem(row, 0, item_date)
            self.table.setItem(row, 1, QTableWidgetItem(label))
            self.table.setItem(row, 2, QTableWidgetItem(f"{amount:.2f}"))

    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_date = self.table.item(row, 0)
        item_label = self.table.item(row, 1)
        item_amount = self.table.item(row, 2)
        if item_date and item_label and item_amount:
            self.date_edit.setDate(
                QDate.fromString(item_date.text(), "yyyy-MM-dd")
            )
            self.label_edit.setText(item_label.text())
            self.amount_spin.setValue(float(item_amount.text()))

===== MOTEUR/scraping/__init__.py =====

===== MOTEUR/scraping/image_scraper/__init__.py =====
"""Universal image scraper package."""

import logging


def configure_logging(verbose: bool = False) -> None:
    """Configure root logging level and format."""

    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s: %(message)s",
        level=logging.DEBUG if verbose else logging.INFO,
    )


configure_logging(False)

===== MOTEUR/scraping/image_scraper/constants.py =====
USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/117.0 Safari/537.36"
)
# Default CSS selector to find product images
IMAGES_DEFAULT_SELECTOR = "img"

COMMON_SELECTORS = [
    "div.woocommerce-product-gallery__image img",
    "figure.woocommerce-product-gallery__wrapper img",
    "img.product-single__photo",
    'img[src*="cdn.shopify.com"]',
    "img.wp-post-image",
]

===== MOTEUR/scraping/image_scraper/download.py =====
from __future__ import annotations

import base64
import binascii
import logging
import mimetypes
import os
import re
from pathlib import Path

import requests


class ImageDownloadError(RuntimeError):
    """Raised when a binary or base64 download fails."""

    pass


from .constants import USER_AGENT
from .utils import retry_on_stale

logger = logging.getLogger(__name__)


def download_binary(url: str, path: Path, user_agent: str = USER_AGENT) -> Path:
    """Download binary content from *url* into *path* using *user_agent*."""
    headers = {"User-Agent": user_agent}
    try:
        with requests.get(url, headers=headers, stream=True, timeout=10) as resp:
            resp.raise_for_status()
            final_path = path
            if not path.suffix:
                ctype = resp.headers.get("Content-Type", "").split(";")[0]
                ext = mimetypes.guess_extension(ctype) or ".bin"
                final_path = path.with_suffix(ext)
            with final_path.open("wb") as fh:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        fh.write(chunk)
            return final_path
    except requests.exceptions.RequestException as exc:
        raise ImageDownloadError(f"Failed to download {url}") from exc


def save_base64(encoded: str, path: Path) -> None:
    """Decode base64 *encoded* data and write it to *path*."""
    try:
        data = base64.b64decode(encoded)
    except binascii.Error as exc:
        raise ImageDownloadError("Invalid base64 image data") from exc
    path.write_bytes(data)


def unique_path(folder: Path, filename: str, reserved: set[Path]) -> Path:
    """Return a unique ``Path`` in *folder* for *filename*."""
    base, ext = os.path.splitext(filename)
    candidate = folder / filename
    counter = 1
    while candidate.exists() or candidate in reserved:
        candidate = folder / f"{base}_{counter}{ext}"
        counter += 1
    reserved.add(candidate)
    return candidate


@retry_on_stale()
def handle_image(
    element, folder: Path, index: int, user_agent: str, reserved: set[Path]
) -> tuple[Path | None, str | None]:
    """Return target path and optional URL for *element* image."""
    src = (
        element.get_attribute("src")
        or element.get_attribute("data-src")
        or element.get_attribute("currentSrc")
        or element.get_attribute("srcset")
        or element.get_attribute("data-srcset")
    )
    if not src:
        raise RuntimeError("Aucun attribut src / data-src trouvé pour l'image")

    if " " in src and "," in src:
        candidates = [s.strip().split(" ")[0] for s in src.split(",")]
        src = candidates[-1]

    width = int(element.get_attribute("naturalWidth") or 0)
    height = int(element.get_attribute("naturalHeight") or 0)
    if width and width < 200 or height and height < 200:
        return None, None
    if re.search(r"/(logo|icon|sprite)/", src):
        return None, None

    logger.debug("Téléchargement de l'image : %s", src)

    if src.startswith("data:image"):
        header, encoded = src.split(",", 1)
        ext = header.split("/")[1].split(";")[0]
        filename = f"image_base64_{index}.{ext}"
        target = unique_path(folder, filename, reserved)
        save_base64(encoded, target)
        return target, None

    if src.startswith("//"):
        src = "https:" + src

    raw_filename = os.path.basename(src.split("?")[0])
    base, ext = os.path.splitext(raw_filename)
    base = re.sub(r"-?\d+$", "", base)
    base = re.sub(r"\d+", "", base)
    filename = f"{base}{ext}"
    target = unique_path(folder, filename, reserved)
    return target, src

===== MOTEUR/scraping/image_scraper/driver.py =====
from __future__ import annotations

import shutil

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager


def setup_driver(
    headless: bool = True,
    *,
    window_size: tuple[int, int] | None = (1920, 1080),
    timeout: int | None = None,
    chromedriver_path: str | None = None,
) -> webdriver.Chrome:
    """Return a configured Selenium Chrome driver.

    Parameters
    ----------
    headless:
        Launch Chrome in headless mode.
    window_size:
        Desired window size ``(width, height)`` or ``None`` to keep the
        browser default.
    timeout:
        Page load timeout in seconds, ``None`` to disable.
    chromedriver_path:
        Explicit path to the chromedriver binary. If ``None``, the driver
        must be available in ``PATH``.
    """
    options = Options()
    if headless:
        options.add_argument("--headless=new")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.add_experimental_option("useAutomationExtension", False)
    if window_size is not None:
        width, height = window_size
        options.add_argument(f"--window-size={width},{height}")
    if chromedriver_path:
        service = Service(executable_path=chromedriver_path)
    else:
        path = shutil.which("chromedriver")
        if not path:
            try:
                path = ChromeDriverManager().install()
            except Exception as exc:
                raise FileNotFoundError("chromedriver not found in PATH") from exc
        service = Service(executable_path=path)
    driver = webdriver.Chrome(service=service, options=options)
    driver.execute_cdp_cmd(
        "Page.addScriptToEvaluateOnNewDocument",
        {
            "source": "Object.defineProperty(navigator,'webdriver',{get:() => undefined});"
        },
    )
    if timeout is not None:
        driver.set_page_load_timeout(timeout)
    return driver

===== MOTEUR/scraping/image_scraper/product_sentences.json =====
{}

===== MOTEUR/scraping/image_scraper/rename.py =====
from __future__ import annotations

import json
import logging
import random
import re
import unicodedata
from pathlib import Path

from .download import unique_path

ALT_JSON_PATH = Path(__file__).with_name("product_sentences.json")
USE_ALT_JSON = True

logger = logging.getLogger(__name__)

_ALT_SENTENCES_CACHE: dict[Path, dict] = {}


def load_alt_sentences(path: Path = ALT_JSON_PATH) -> dict:
    """Load and cache ALT sentences from *path*."""
    path = Path(path)
    cached = _ALT_SENTENCES_CACHE.get(path)
    if cached is not None:
        return cached
    try:
        with path.open("r", encoding="utf-8") as fh:
            data = json.load(fh)
    except Exception as exc:
        logger.warning("Impossible de charger %s : %s", path, exc)
        data = {}
    _ALT_SENTENCES_CACHE[path] = data
    return data


def clean_filename(text: str) -> str:
    """Return *text* transformed into a safe file name."""
    normalized = unicodedata.normalize("NFD", text)
    ascii_text = normalized.encode("ascii", "ignore").decode("ascii")
    ascii_text = ascii_text.lower()
    ascii_text = re.sub(r"[\s-]+", "_", ascii_text)
    ascii_text = re.sub(r"[^a-z0-9_]", "", ascii_text)
    return ascii_text


def rename_with_alt(
    path: Path, sentences: dict, warned: set[str], reserved: set[Path]
) -> Path:
    """Rename *path* using ALT sentences if available."""
    product_key = path.parent.name.replace("_", " ")
    phrase_list = sentences.get(product_key)
    if not phrase_list:
        if product_key not in warned:
            logger.warning(
                "Cle '%s' absente de product_sentences.json, pas de renommage",
                product_key,
            )
            warned.add(product_key)
        return path

    alt_phrase = random.choice(phrase_list)
    filename = clean_filename(alt_phrase) + path.suffix
    target = path.parent / filename
    if target != path and target.exists():
        target = unique_path(path.parent, filename, reserved)
    try:
        path.rename(target)
    except OSError as exc:
        logger.warning("Echec du renommage %s -> %s : %s", path, target, exc)
        return path
    return target

===== MOTEUR/scraping/image_scraper/scraper.py =====
#!/usr/bin/env python3
"""Utilities to download product images from a webpage."""

from __future__ import annotations

import logging
import os
import re
import subprocess
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Callable, Optional

from selenium.common.exceptions import TimeoutException
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from tqdm import tqdm

from . import download as dl_helpers
from . import rename as rename_helpers
from .constants import COMMON_SELECTORS
from .constants import IMAGES_DEFAULT_SELECTOR as DEFAULT_CSS_SELECTOR
from .constants import USER_AGENT
from .driver import setup_driver
from .utils import check_robots, exhaust_carousel
from ..scraping_variantes import extract_variants_with_images

logger = logging.getLogger(__name__)


def _safe_folder(product_name: str, base_dir: Path | str = "images") -> Path:
    """Return a Path where images will be saved."""
    safe_name = re.sub(r"[^\w\-]", "_", product_name)
    folder = Path(base_dir) / safe_name
    folder.mkdir(parents=True, exist_ok=True)
    return folder


def _open_folder(path: Path) -> None:
    """Open *path* in the system file explorer if possible."""
    try:
        if os.name == "nt":
            os.startfile(path)  # type: ignore[attr-defined]
        elif sys.platform == "darwin":
            subprocess.Popen(["open", path])
        else:
            subprocess.Popen(["xdg-open", path])
    except Exception as exc:  # pragma: no cover - platform dependent
        logger.warning("Impossible d'ouvrir le dossier %s : %s", path, exc)


def _find_product_name(driver) -> str:
    """Return the product name found in the page."""
    selectors = [
        (By.CSS_SELECTOR, "meta[property='og:title']", "content"),
        (By.TAG_NAME, "title", None),
        (By.TAG_NAME, "h1", None),
    ]
    for by, value, attr in selectors:
        try:
            elem = driver.find_element(by, value)
            text = elem.get_attribute(attr) if attr else getattr(elem, "text", "")
            if text:
                text = text.strip()
            if text:
                return text
        except Exception:
            continue
    return "produit"


def download_images(
    url: str,
    css_selector: str = DEFAULT_CSS_SELECTOR,
    parent_dir: Path | str = "images",
    progress_callback: Optional[Callable[[int, int], None]] = None,
    user_agent: str = USER_AGENT,
    use_alt_json: bool = rename_helpers.USE_ALT_JSON,
    *,
    alt_json_path: str | Path | None = None,
    max_threads: int = 4,
    carousel_selector: str | None = None,
) -> dict:
    """Download all images from *url* and return folder and first image."""
    reserved_paths: set[Path] = set()

    check_robots(url)

    driver = setup_driver(window_size=(1920, 1080), timeout=None)
    driver.execute_cdp_cmd(
        "Network.setUserAgentOverride",
        {"userAgent": user_agent},
    )

    product_name = ""
    folder = Path()
    first_image: Path | None = None
    downloaded = 0
    skipped = 0

    if use_alt_json and alt_json_path:
        sentences = rename_helpers.load_alt_sentences(Path(alt_json_path))
    else:
        sentences = {}
        use_alt_json = False
    warned_missing: set[str] = set()

    try:
        logger.info("\U0001f30d Chargement de la page...")
        driver.get(url)
        try:
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, css_selector))
            )
        except TimeoutException:
            logger.error("Timeout waiting for elements with selector %s", css_selector)
            driver.quit()
            try:
                title, mapping = extract_variants_with_images(url)
            except Exception as exc:
                logger.error("Variant fallback failed: %s", exc)
                return {"folder": folder, "first_image": first_image}

            folder = _safe_folder(title, parent_dir)
            for idx, img_url in enumerate(mapping.values(), start=1):
                filename = os.path.basename(img_url.split("?")[0])
                path = dl_helpers.unique_path(folder, filename, reserved_paths)
                try:
                    dl_helpers.download_binary(img_url, path, user_agent)
                    if use_alt_json:
                        path = rename_helpers.rename_with_alt(
                            path, sentences, warned_missing, reserved_paths
                        )
                    if first_image is None:
                        first_image = path
                    downloaded += 1
                except Exception as exc:  # pragma: no cover - network issues
                    logger.error("\u274c Erreur pour l'image %s : %s", idx, exc)
                    skipped += 1
            logger.info(
                "\n\U0001f5bc %d images téléchargées via variante", downloaded
            )
            return {"folder": folder, "first_image": first_image}

        product_name = _find_product_name(driver)
        folder = _safe_folder(product_name, parent_dir)

        if carousel_selector:
            try:
                carousel_root = driver.find_element(By.CSS_SELECTOR, carousel_selector)
                img_elements = exhaust_carousel(carousel_root)
            except Exception as exc:
                logger.warning("Carousel not found %s: %s", carousel_selector, exc)
                img_elements = []
        else:
            img_elements = []

        selectors_to_try = [css_selector] + COMMON_SELECTORS
        chosen_selector = css_selector
        for sel in selectors_to_try:
            if img_elements:
                break
            elems = driver.find_elements(By.CSS_SELECTOR, sel)
            if elems:
                img_elements = elems
                chosen_selector = sel
        css_selector = chosen_selector
        logger.info(
            f"\n\U0001f5bc {len(img_elements)} images trouvées avec le "
            f"sélecteur : {css_selector}\n"
        )

        total = len(img_elements)
        pbar = tqdm(range(total), desc="\U0001f53d Téléchargement des images")
        pbar_update = getattr(pbar, "update", lambda n=1: None)
        pbar_close = getattr(pbar, "close", lambda: None)
        futures: dict = {}
        done_count = 0

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            for idx, img in enumerate(img_elements, start=1):
                try:
                    path, url_to_download = dl_helpers.handle_image(
                        img, folder, idx, user_agent, reserved_paths
                    )
                    if path is None:
                        skipped += 1
                        pbar_update(1)
                        done_count += 1
                        if progress_callback:
                            progress_callback(done_count, total)
                        continue

                    WebDriverWait(driver, 5).until(
                        lambda d: img.get_attribute("src")
                        or img.get_attribute("data-src")
                        or img.get_attribute("data-srcset")
                    )
                    if url_to_download is None:
                        if use_alt_json:
                            path = rename_helpers.rename_with_alt(
                                path, sentences, warned_missing, reserved_paths
                            )
                        downloaded += 1
                        if first_image is None:
                            first_image = path
                        pbar_update(1)
                        done_count += 1
                        if progress_callback:
                            progress_callback(done_count, total)
                    else:
                        fut = executor.submit(
                            dl_helpers.download_binary,
                            url_to_download,
                            path,
                            user_agent,
                        )
                        futures[fut] = (idx, path)
                except Exception as exc:
                    logger.error("\u274c Erreur pour l'image %s : %s", idx, exc)
            for fut in as_completed(futures):
                idx, orig_path = futures[fut]
                try:
                    path = fut.result()
                    if use_alt_json:
                        path = rename_helpers.rename_with_alt(
                            path, sentences, warned_missing, reserved_paths
                        )
                    downloaded += 1
                    if first_image is None:
                        first_image = path
                except Exception as exc:
                    logger.error("\u274c Erreur pour l'image %s : %s", idx, exc)
                    skipped += 1
                pbar_update(1)
                done_count += 1
                if progress_callback:
                    progress_callback(done_count, total)
        pbar_close()
        if progress_callback and done_count != total:
            progress_callback(total, total)
    finally:
        driver.quit()

    logger.info("\n" + "-" * 50)
    logger.info("\U0001f3af Produit     : %s", product_name)
    logger.info("\U0001f4e6 Dossier     : %s", folder)
    logger.info("\u2705 Téléchargées : %s", downloaded)
    logger.info("\u27a1️ Ignorées     : %s", skipped)
    logger.info("-" * 50)

    return {"folder": folder, "first_image": first_image}

===== MOTEUR/scraping/image_scraper/utils.py =====
from __future__ import annotations

import logging
import time
from functools import wraps
from urllib.parse import urlparse

import requests
from selenium.common.exceptions import StaleElementReferenceException
from selenium.webdriver.common.by import By

logger = logging.getLogger(__name__)


def retry_on_stale(max_retry: int = 3, delay: float = 0.4):
    """Retry function if a ``StaleElementReferenceException`` occurs."""

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            while True:
                try:
                    return func(*args, **kwargs)
                except StaleElementReferenceException:
                    attempts += 1
                    if attempts >= max_retry:
                        raise
                    time.sleep(delay)

        return wrapper

    return decorator


def exhaust_carousel(carousel_root):
    """Return all unique ``<img>`` elements within a carousel."""
    imgs: dict[int, any] = {}
    imgs.update(
        {id(img): img for img in carousel_root.find_elements(By.CSS_SELECTOR, "img")}
    )
    try:
        next_btn = carousel_root.find_element(
            By.CSS_SELECTOR, "[class*='next'], [aria-label*='next']"
        )
    except Exception:
        next_btn = None
    while (
        next_btn
        and next_btn.is_enabled()
        and next_btn.get_attribute("aria-disabled") != "true"
    ):
        next_btn.click()
        time.sleep(0.2)
        for img in carousel_root.find_elements(By.CSS_SELECTOR, "img"):
            imgs.setdefault(id(img), img)
        if (
            not next_btn.is_enabled()
            or next_btn.get_attribute("aria-disabled") == "true"
        ):
            break
    return list(imgs.values())


def check_robots(url: str) -> None:
    """Download and display relevant ``Disallow`` lines from robots.txt."""
    parsed = urlparse(url)
    robots_url = f"{parsed.scheme}://{parsed.netloc}/robots.txt"
    try:
        resp = requests.get(robots_url, timeout=5)
        if resp.status_code == 200:
            lines = [l for l in resp.text.splitlines() if "Disallow" in l]
            if lines:
                logger.info("Robots.txt:\n%s", "\n".join(lines))
    except Exception:
        pass

===== MOTEUR/scraping/profiles/__init__.py =====

===== MOTEUR/scraping/profiles/manager.py =====
from __future__ import annotations

import json
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, Optional

from ..image_scraper.constants import IMAGES_DEFAULT_SELECTOR


def fix_css_selector(selector: str) -> str:
    """Return *selector* with missing class dots added.

    Tokens that look like class names (contain a hyphen and are not already
    prefixed with ``.``, ``#`` or other CSS characters) are automatically
    prefixed with ``.``. This helps users who omit dots when entering class
    names like ``product-gallery media-carousel``.
    """
    fixed_tokens: list[str] = []
    for tok in selector.split():
        if (
            tok
            and not tok.startswith(('.', '#', '[', ':', '>'))
            and '-' in tok
            and not any(ch in tok for ch in '.#[:>')
        ):
            fixed_tokens.append('.' + tok)
        else:
            fixed_tokens.append(tok)
    return ' '.join(fixed_tokens)


@dataclass
class Profile:
    """Simple container for a scraping profile."""

    css_selector: str
    domain: str = "https://www.planetebob.fr"
    date: str = "2025/07"
    url_file: str = ""


class ProfileManager:
    """Manage scraping profiles stored in a JSON file."""

    def __init__(self, path: Path | str | None = None) -> None:
        self.path = (
            Path(path)
            if path is not None
            else Path(__file__).with_name("profiles.json")
        )
        self.profiles: Dict[str, Profile] = {}
        self.load_profiles()

    def load_profiles(self) -> None:
        """Load profiles from the JSON file or create defaults."""
        if self.path.exists():
            try:
                with self.path.open("r", encoding="utf-8") as fh:
                    data = json.load(fh)
                if isinstance(data, dict):
                    self.profiles = {}
                    for k, v in data.items():
                        if isinstance(v, str):
                            self.profiles[str(k)] = Profile(v)
                        elif isinstance(v, dict):
                            self.profiles[str(k)] = Profile(
                                fix_css_selector(v.get("css", IMAGES_DEFAULT_SELECTOR)),
                                v.get("domain", "https://www.planetebob.fr"),
                                v.get("date", "2025/07"),
                                v.get("url_file", ""),
                            )
                else:
                    self.profiles = {}
            except Exception:
                self.profiles = {}
        else:
            self.profiles = {"default": Profile(fix_css_selector(IMAGES_DEFAULT_SELECTOR))}
            self.save_profiles()

    def save_profiles(self) -> None:
        """Write current profiles to the JSON file."""
        with self.path.open("w", encoding="utf-8") as fh:
            json.dump(
                {
                    name: {
                        "css": p.css_selector,
                        "domain": p.domain,
                        "date": p.date,
                        "url_file": p.url_file,
                    }
                    for name, p in self.profiles.items()
                },
                fh,
                ensure_ascii=False,
                indent=2,
            )

    def get_profile(self, name: str) -> Optional[Profile]:
        """Return the profile for *name* if present."""
        prof = self.profiles.get(name)
        if prof:
            prof.css_selector = fix_css_selector(prof.css_selector)
        return prof

    def add_or_update_profile(
        self, name: str, css: str, domain: str, date: str, url_file: str = ""
    ) -> None:
        """Add or update *name* with profile parameters and persist it."""
        self.profiles[name] = Profile(fix_css_selector(css), domain, date, url_file)
        self.save_profiles()

    def remove_profile(self, name: str) -> None:
        """Delete *name* from profiles if present and persist."""
        if name in self.profiles:
            del self.profiles[name]
            self.save_profiles()

===== MOTEUR/scraping/scraping.txt =====
Code listing for scraping module
===== Changelog =====
- Ajout du chargement d'URLs depuis un fichier de profil
- Prise en charge du scraping de plusieurs URLs à la suite
- Suppression du champ de lien concurrent dans le widget combiné
- Correction automatique des sélecteurs CSS invalides
- Export CSV des variantes à partir du widget combiné
- Onglet paramètres pour activer ou désactiver les modules


===== MOTEUR/scraping/__init__.py =====


===== MOTEUR/scraping/image_scraper/__init__.py =====

"""Universal image scraper package."""

import logging


def configure_logging(verbose: bool = False) -> None:
    """Configure root logging level and format."""

    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s: %(message)s",
        level=logging.DEBUG if verbose else logging.INFO,
    )


configure_logging(False)

===== MOTEUR/scraping/image_scraper/constants.py =====

USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/117.0 Safari/537.36"
)
# Default CSS selector to find product images
IMAGES_DEFAULT_SELECTOR = "img"

COMMON_SELECTORS = [
    "div.woocommerce-product-gallery__image img",
    "figure.woocommerce-product-gallery__wrapper img",
    "img.product-single__photo",
    'img[src*="cdn.shopify.com"]',
    "img.wp-post-image",
]

===== MOTEUR/scraping/image_scraper/download.py =====

from __future__ import annotations

import base64
import binascii
import logging
import mimetypes
import os
import re
from pathlib import Path

import requests


class ImageDownloadError(RuntimeError):
    """Raised when a binary or base64 download fails."""

    pass


from .constants import USER_AGENT
from .utils import retry_on_stale

logger = logging.getLogger(__name__)


def download_binary(url: str, path: Path, user_agent: str = USER_AGENT) -> Path:
    """Download binary content from *url* into *path* using *user_agent*."""
    headers = {"User-Agent": user_agent}
    try:
        with requests.get(url, headers=headers, stream=True, timeout=10) as resp:
            resp.raise_for_status()
            final_path = path
            if not path.suffix:
                ctype = resp.headers.get("Content-Type", "").split(";")[0]
                ext = mimetypes.guess_extension(ctype) or ".bin"
                final_path = path.with_suffix(ext)
            with final_path.open("wb") as fh:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        fh.write(chunk)
            return final_path
    except requests.exceptions.RequestException as exc:
        raise ImageDownloadError(f"Failed to download {url}") from exc


def save_base64(encoded: str, path: Path) -> None:
    """Decode base64 *encoded* data and write it to *path*."""
    try:
        data = base64.b64decode(encoded)
    except binascii.Error as exc:
        raise ImageDownloadError("Invalid base64 image data") from exc
    path.write_bytes(data)


def unique_path(folder: Path, filename: str, reserved: set[Path]) -> Path:
    """Return a unique ``Path`` in *folder* for *filename*."""
    base, ext = os.path.splitext(filename)
    candidate = folder / filename
    counter = 1
    while candidate.exists() or candidate in reserved:
        candidate = folder / f"{base}_{counter}{ext}"
        counter += 1
    reserved.add(candidate)
    return candidate


@retry_on_stale()
def handle_image(
    element, folder: Path, index: int, user_agent: str, reserved: set[Path]
) -> tuple[Path | None, str | None]:
    """Return target path and optional URL for *element* image."""
    src = (
        element.get_attribute("src")
        or element.get_attribute("data-src")
        or element.get_attribute("currentSrc")
        or element.get_attribute("srcset")
        or element.get_attribute("data-srcset")
    )
    if not src:
        raise RuntimeError("Aucun attribut src / data-src trouvé pour l'image")

    if " " in src and "," in src:
        candidates = [s.strip().split(" ")[0] for s in src.split(",")]
        src = candidates[-1]

    width = int(element.get_attribute("naturalWidth") or 0)
    height = int(element.get_attribute("naturalHeight") or 0)
    if width and width < 200 or height and height < 200:
        return None, None
    if re.search(r"/(logo|icon|sprite)/", src):
        return None, None

    logger.debug("Téléchargement de l'image : %s", src)

    if src.startswith("data:image"):
        header, encoded = src.split(",", 1)
        ext = header.split("/")[1].split(";")[0]
        filename = f"image_base64_{index}.{ext}"
        target = unique_path(folder, filename, reserved)
        save_base64(encoded, target)
        return target, None

    if src.startswith("//"):
        src = "https:" + src

    raw_filename = os.path.basename(src.split("?")[0])
    base, ext = os.path.splitext(raw_filename)
    base = re.sub(r"-?\d+$", "", base)
    base = re.sub(r"\d+", "", base)
    filename = f"{base}{ext}"
    target = unique_path(folder, filename, reserved)
    return target, src

===== MOTEUR/scraping/image_scraper/driver.py =====

from __future__ import annotations

import shutil

from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager


def setup_driver(
    headless: bool = True,
    *,
    window_size: tuple[int, int] | None = (1920, 1080),
    timeout: int | None = None,
    chromedriver_path: str | None = None,
) -> webdriver.Chrome:
    """Return a configured Selenium Chrome driver.

    Parameters
    ----------
    headless:
        Launch Chrome in headless mode.
    window_size:
        Desired window size ``(width, height)`` or ``None`` to keep the
        browser default.
    timeout:
        Page load timeout in seconds, ``None`` to disable.
    chromedriver_path:
        Explicit path to the chromedriver binary. If ``None``, a driver is
        fetched automatically with ``webdriver-manager`` or found in ``PATH``.
    """
    options = Options()
    if headless:
        options.add_argument("--headless=new")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.add_experimental_option("useAutomationExtension", False)
    if window_size is not None:
        width, height = window_size
        options.add_argument(f"--window-size={width},{height}")
    if chromedriver_path:
        service = Service(executable_path=chromedriver_path)
    else:
        path = shutil.which("chromedriver")
        if not path:
            try:
                path = ChromeDriverManager().install()
            except Exception as exc:
                raise FileNotFoundError("chromedriver not found in PATH") from exc
        service = Service(executable_path=path)
    driver = webdriver.Chrome(service=service, options=options)
    driver.execute_cdp_cmd(
        "Page.addScriptToEvaluateOnNewDocument",
        {
            "source": "Object.defineProperty(navigator,'webdriver',{get:() => undefined});"
        },
    )
    if timeout is not None:
        driver.set_page_load_timeout(timeout)
    return driver

===== MOTEUR/scraping/image_scraper/rename.py =====

from __future__ import annotations

import json
import logging
import random
import re
import unicodedata
from pathlib import Path

from .download import unique_path

ALT_JSON_PATH = Path(__file__).with_name("product_sentences.json")
USE_ALT_JSON = True

logger = logging.getLogger(__name__)

_ALT_SENTENCES_CACHE: dict[Path, dict] = {}


def load_alt_sentences(path: Path = ALT_JSON_PATH) -> dict:
    """Load and cache ALT sentences from *path*."""
    path = Path(path)
    cached = _ALT_SENTENCES_CACHE.get(path)
    if cached is not None:
        return cached
    try:
        with path.open("r", encoding="utf-8") as fh:
            data = json.load(fh)
    except Exception as exc:
        logger.warning("Impossible de charger %s : %s", path, exc)
        data = {}
    _ALT_SENTENCES_CACHE[path] = data
    return data


def clean_filename(text: str) -> str:
    """Return *text* transformed into a safe file name."""
    normalized = unicodedata.normalize("NFD", text)
    ascii_text = normalized.encode("ascii", "ignore").decode("ascii")
    ascii_text = ascii_text.lower()
    ascii_text = re.sub(r"\s+", "_", ascii_text)
    ascii_text = re.sub(r"[^a-z0-9_-]", "", ascii_text)
    return ascii_text


def rename_with_alt(
    path: Path, sentences: dict, warned: set[str], reserved: set[Path]
) -> Path:
    """Rename *path* using ALT sentences if available."""
    product_key = path.parent.name.replace("_", " ")
    phrase_list = sentences.get(product_key)
    if not phrase_list:
        if product_key not in warned:
            logger.warning(
                "Cle '%s' absente de product_sentences.json, pas de renommage",
                product_key,
            )
            warned.add(product_key)
        return path

    alt_phrase = random.choice(phrase_list)
    filename = clean_filename(alt_phrase) + path.suffix
    target = path.parent / filename
    if target != path and target.exists():
        target = unique_path(path.parent, filename, reserved)
    try:
        path.rename(target)
    except OSError as exc:
        logger.warning("Echec du renommage %s -> %s : %s", path, target, exc)
        return path
    return target

===== MOTEUR/scraping/image_scraper/scraper.py =====

#!/usr/bin/env python3
"""Utilities to download product images from a webpage."""

from __future__ import annotations

import logging
import os
import re
import subprocess
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Callable, Optional

from selenium.common.exceptions import TimeoutException
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from tqdm import tqdm

from . import download as dl_helpers
from . import rename as rename_helpers
from .constants import COMMON_SELECTORS
from .constants import IMAGES_DEFAULT_SELECTOR as DEFAULT_CSS_SELECTOR
from .constants import USER_AGENT
from .driver import setup_driver
from .utils import check_robots, exhaust_carousel

logger = logging.getLogger(__name__)


def _safe_folder(product_name: str, base_dir: Path | str = "images") -> Path:
    """Return a Path where images will be saved."""
    safe_name = re.sub(r"[^\w\-]", "_", product_name)
    folder = Path(base_dir) / safe_name
    folder.mkdir(parents=True, exist_ok=True)
    return folder


def _open_folder(path: Path) -> None:
    """Open *path* in the system file explorer if possible."""
    try:
        if os.name == "nt":
            os.startfile(path)  # type: ignore[attr-defined]
        elif sys.platform == "darwin":
            subprocess.Popen(["open", path])
        else:
            subprocess.Popen(["xdg-open", path])
    except Exception as exc:  # pragma: no cover - platform dependent
        logger.warning("Impossible d'ouvrir le dossier %s : %s", path, exc)


def _find_product_name(driver) -> str:
    """Return the product name found in the page."""
    selectors = [
        (By.CSS_SELECTOR, "meta[property='og:title']", "content"),
        (By.TAG_NAME, "title", None),
        (By.TAG_NAME, "h1", None),
    ]
    for by, value, attr in selectors:
        try:
            elem = driver.find_element(by, value)
            text = elem.get_attribute(attr) if attr else getattr(elem, "text", "")
            if text:
                text = text.strip()
            if text:
                return text
        except Exception:
            continue
    return "produit"


def download_images(
    url: str,
    css_selector: str = DEFAULT_CSS_SELECTOR,
    parent_dir: Path | str = "images",
    progress_callback: Optional[Callable[[int, int], None]] = None,
    user_agent: str = USER_AGENT,
    use_alt_json: bool = rename_helpers.USE_ALT_JSON,
    *,
    alt_json_path: str | Path | None = None,
    max_threads: int = 4,
    carousel_selector: str | None = None,
) -> dict:
    """Download all images from *url* and return folder and first image."""
    reserved_paths: set[Path] = set()

    check_robots(url)

    driver = setup_driver(window_size=(1920, 1080), timeout=None)
    driver.execute_cdp_cmd(
        "Network.setUserAgentOverride",
        {"userAgent": user_agent},
    )

    product_name = ""
    folder = Path()
    first_image: Path | None = None
    downloaded = 0
    skipped = 0

    if use_alt_json and alt_json_path:
        sentences = rename_helpers.load_alt_sentences(Path(alt_json_path))
    else:
        sentences = {}
        use_alt_json = False
    warned_missing: set[str] = set()

    try:
        logger.info("\U0001f30d Chargement de la page...")
        driver.get(url)
        try:
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, css_selector))
            )
        except TimeoutException:
            logger.error("Timeout waiting for elements with selector %s", css_selector)
            return {"folder": folder, "first_image": first_image}

        product_name = _find_product_name(driver)
        folder = _safe_folder(product_name, parent_dir)

        if carousel_selector:
            try:
                carousel_root = driver.find_element(By.CSS_SELECTOR, carousel_selector)
                img_elements = exhaust_carousel(carousel_root)
            except Exception as exc:
                logger.warning("Carousel not found %s: %s", carousel_selector, exc)
                img_elements = []
        else:
            img_elements = []

        selectors_to_try = [css_selector] + COMMON_SELECTORS
        chosen_selector = css_selector
        for sel in selectors_to_try:
            if img_elements:
                break
            elems = driver.find_elements(By.CSS_SELECTOR, sel)
            if elems:
                img_elements = elems
                chosen_selector = sel
        css_selector = chosen_selector
        logger.info(
            f"\n\U0001f5bc {len(img_elements)} images trouvées avec le "
            f"sélecteur : {css_selector}\n"
        )

        total = len(img_elements)
        pbar = tqdm(range(total), desc="\U0001f53d Téléchargement des images")
        pbar_update = getattr(pbar, "update", lambda n=1: None)
        pbar_close = getattr(pbar, "close", lambda: None)
        futures: dict = {}
        done_count = 0

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            for idx, img in enumerate(img_elements, start=1):
                try:
                    path, url_to_download = dl_helpers.handle_image(
                        img, folder, idx, user_agent, reserved_paths
                    )
                    if path is None:
                        skipped += 1
                        pbar_update(1)
                        done_count += 1
                        if progress_callback:
                            progress_callback(done_count, total)
                        continue

                    WebDriverWait(driver, 5).until(
                        lambda d: img.get_attribute("src")
                        or img.get_attribute("data-src")
                        or img.get_attribute("data-srcset")
                    )
                    if url_to_download is None:
                        if use_alt_json:
                            path = rename_helpers.rename_with_alt(
                                path, sentences, warned_missing, reserved_paths
                            )
                        downloaded += 1
                        if first_image is None:
                            first_image = path
                        pbar_update(1)
                        done_count += 1
                        if progress_callback:
                            progress_callback(done_count, total)
                    else:
                        fut = executor.submit(
                            dl_helpers.download_binary,
                            url_to_download,
                            path,
                            user_agent,
                        )
                        futures[fut] = (idx, path)
                except Exception as exc:
                    logger.error("\u274c Erreur pour l'image %s : %s", idx, exc)
            for fut in as_completed(futures):
                idx, orig_path = futures[fut]
                try:
                    path = fut.result()
                    if use_alt_json:
                        path = rename_helpers.rename_with_alt(
                            path, sentences, warned_missing, reserved_paths
                        )
                    downloaded += 1
                    if first_image is None:
                        first_image = path
                except Exception as exc:
                    logger.error("\u274c Erreur pour l'image %s : %s", idx, exc)
                    skipped += 1
                pbar_update(1)
                done_count += 1
                if progress_callback:
                    progress_callback(done_count, total)
        pbar_close()
        if progress_callback and done_count != total:
            progress_callback(total, total)
    finally:
        driver.quit()

    logger.info("\n" + "-" * 50)
    logger.info("\U0001f3af Produit     : %s", product_name)
    logger.info("\U0001f4e6 Dossier     : %s", folder)
    logger.info("\u2705 Téléchargées : %s", downloaded)
    logger.info("\u27a1️ Ignorées     : %s", skipped)
    logger.info("-" * 50)

    return {"folder": folder, "first_image": first_image}

===== MOTEUR/scraping/image_scraper/utils.py =====

from __future__ import annotations

import logging
import time
from functools import wraps
from urllib.parse import urlparse

import requests
from selenium.common.exceptions import StaleElementReferenceException
from selenium.webdriver.common.by import By

logger = logging.getLogger(__name__)


def retry_on_stale(max_retry: int = 3, delay: float = 0.4):
    """Retry function if a ``StaleElementReferenceException`` occurs."""

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            while True:
                try:
                    return func(*args, **kwargs)
                except StaleElementReferenceException:
                    attempts += 1
                    if attempts >= max_retry:
                        raise
                    time.sleep(delay)

        return wrapper

    return decorator


def exhaust_carousel(carousel_root):
    """Return all unique ``<img>`` elements within a carousel."""
    imgs: dict[int, any] = {}
    imgs.update(
        {id(img): img for img in carousel_root.find_elements(By.CSS_SELECTOR, "img")}
    )
    try:
        next_btn = carousel_root.find_element(
            By.CSS_SELECTOR, "[class*='next'], [aria-label*='next']"
        )
    except Exception:
        next_btn = None
    while (
        next_btn
        and next_btn.is_enabled()
        and next_btn.get_attribute("aria-disabled") != "true"
    ):
        next_btn.click()
        time.sleep(0.2)
        for img in carousel_root.find_elements(By.CSS_SELECTOR, "img"):
            imgs.setdefault(id(img), img)
        if (
            not next_btn.is_enabled()
            or next_btn.get_attribute("aria-disabled") == "true"
        ):
            break
    return list(imgs.values())


def check_robots(url: str) -> None:
    """Download and display relevant ``Disallow`` lines from robots.txt."""
    parsed = urlparse(url)
    robots_url = f"{parsed.scheme}://{parsed.netloc}/robots.txt"
    try:
        resp = requests.get(robots_url, timeout=5)
        if resp.status_code == 200:
            lines = [l for l in resp.text.splitlines() if "Disallow" in l]
            if lines:
                logger.info("Robots.txt:\n%s", "\n".join(lines))
    except Exception:
        pass

===== MOTEUR/scraping/profiles/__init__.py =====


===== MOTEUR/scraping/profiles/manager.py =====

from __future__ import annotations

import json
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, Optional

from ..image_scraper.constants import IMAGES_DEFAULT_SELECTOR


@dataclass
class Profile:
    """Simple container for a scraping profile."""

    css_selector: str
    domain: str = "https://www.planetebob.fr"
    date: str = "2025/07"
    url_file: str = ""


class ProfileManager:
    """Manage scraping profiles stored in a JSON file."""

    def __init__(self, path: Path | str | None = None) -> None:
        self.path = (
            Path(path)
            if path is not None
            else Path(__file__).with_name("profiles.json")
        )
        self.profiles: Dict[str, Profile] = {}
        self.load_profiles()

    def load_profiles(self) -> None:
        """Load profiles from the JSON file or create defaults."""
        if self.path.exists():
            try:
                with self.path.open("r", encoding="utf-8") as fh:
                    data = json.load(fh)
                if isinstance(data, dict):
                    self.profiles = {}
                    for k, v in data.items():
                        if isinstance(v, str):
                            self.profiles[str(k)] = Profile(v)
                        elif isinstance(v, dict):
                            self.profiles[str(k)] = Profile(
                                v.get("css", IMAGES_DEFAULT_SELECTOR),
                                v.get("domain", "https://www.planetebob.fr"),
                                v.get("date", "2025/07"),
                                v.get("url_file", ""),
                            )
                else:
                    self.profiles = {}
            except Exception:
                self.profiles = {}
        else:
            self.profiles = {"default": Profile(IMAGES_DEFAULT_SELECTOR)}
            self.save_profiles()

    def save_profiles(self) -> None:
        """Write current profiles to the JSON file."""
        with self.path.open("w", encoding="utf-8") as fh:
            json.dump(
                {
                    name: {
                        "css": p.css_selector,
                        "domain": p.domain,
                        "date": p.date,
                        "url_file": p.url_file,
                    }
                    for name, p in self.profiles.items()
                },
                fh,
                ensure_ascii=False,
                indent=2,
            )

    def get_profile(self, name: str) -> Optional[Profile]:
        """Return the profile for *name* if present."""
        return self.profiles.get(name)

    def add_or_update_profile(
        self, name: str, css: str, domain: str, date: str, url_file: str = ""
    ) -> None:
        """Add or update *name* with profile parameters and persist it."""
        self.profiles[name] = Profile(css, domain, date, url_file)
        self.save_profiles()

    def remove_profile(self, name: str) -> None:
        """Delete *name* from profiles if present and persist."""
        if name in self.profiles:
            del self.profiles[name]
            self.save_profiles()

===== MOTEUR/scraping/widgets/__init__.py =====


===== MOTEUR/scraping/widgets/profile_widget.py =====

from __future__ import annotations

from typing import Optional

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QListWidget,
    QLineEdit,
    QPushButton,
    QMessageBox,
)
from PySide6.QtCore import Signal

from ..profiles.manager import ProfileManager


class ProfileWidget(QWidget):
    """Widget to manage scraping profiles."""

    profile_chosen = Signal(str)

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.manager = ProfileManager()

        main_layout = QVBoxLayout(self)

        # List of existing profiles
        self.profile_list = QListWidget()
        self.profile_list.addItems(sorted(self.manager.profiles))
        self.profile_list.currentItemChanged.connect(self.profile_selected)
        main_layout.addWidget(self.profile_list)

        # Fields to edit profile
        form_layout = QHBoxLayout()
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Nom du profil")
        form_layout.addWidget(self.name_edit)

        self.css_edit = QLineEdit()
        self.css_edit.setPlaceholderText("Sélecteur CSS")
        form_layout.addWidget(self.css_edit)

        main_layout.addLayout(form_layout)

        # Buttons
        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_profile)
        btn_layout.addWidget(self.add_btn)

        self.save_btn = QPushButton("Enregistrer")
        self.save_btn.clicked.connect(self.save_profile)
        btn_layout.addWidget(self.save_btn)

        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.delete_profile)
        btn_layout.addWidget(self.del_btn)

        self.use_btn = QPushButton("Utiliser")
        self.use_btn.clicked.connect(self.use_profile)
        btn_layout.addWidget(self.use_btn)

        main_layout.addLayout(btn_layout)

    # ------------------------------------------------------------------
    def profile_selected(self, current, previous) -> None:  # noqa: D401
        if current:
            name = current.text()
            self.name_edit.setText(name)
            profile = self.manager.get_profile(name)
            css = profile.css_selector if profile else ""
            self.css_edit.setText(css)

    def add_profile(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Profil", "Nom manquant")
            return
        css = self.css_edit.text().strip()
        domain = self.domain_edit.text().strip()
        date = self.date_edit.text().strip()
        url_file = self.url_file_edit.text().strip()
        if name in self.manager.profiles:
            QMessageBox.information(self, "Profil", "Ce profil existe déjà")
            return
        self.manager.add_or_update_profile(name, css, domain, date, url_file)
        self.profile_list.addItem(name)
        self.profile_list.setCurrentRow(self.profile_list.count() - 1)

    def save_profile(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Profil", "Nom manquant")
            return
        css = self.css_edit.text().strip()
        domain = self.domain_edit.text().strip()
        date = self.date_edit.text().strip()
        url_file = self.url_file_edit.text().strip()
        self.manager.add_or_update_profile(name, css, domain, date, url_file)
        # Ensure the list has this profile
        for i in range(self.profile_list.count()):
            if self.profile_list.item(i).text() == name:
                break
        else:
            self.profile_list.addItem(name)
        items = [
            self.profile_list.item(i).text()
            for i in range(self.profile_list.count())
        ]
        self.profile_list.setCurrentRow(items.index(name))

    def delete_profile(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            return
        if name in self.manager.profiles:
            self.manager.remove_profile(name)
        for i in range(self.profile_list.count()):
            if self.profile_list.item(i).text() == name:
                self.profile_list.takeItem(i)
                break
        self.name_edit.clear()
        self.css_edit.clear()
        self.domain_edit.clear()
        self.date_edit.clear()
        self.url_file_edit.clear()
        if self.profile_list.count():
            self.profile_list.setCurrentRow(0)

    def use_profile(self) -> None:
        """Emit the currently selected profile name."""
        name = self.name_edit.text().strip()
        if name:
            self.profile_chosen.emit(name)

===== MOTEUR/scraping/widgets/scraping_widget.py =====

from __future__ import annotations

import logging
from pathlib import Path
from typing import Optional

from PySide6.QtCore import QObject, QThread, QUrl, Signal, Slot
from PySide6.QtGui import QDesktopServices
from PySide6.QtWidgets import (
    QComboBox,
    QFileDialog,
    QHBoxLayout,
    QLineEdit,
    QProgressBar,
    QPushButton,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from ..image_scraper.constants import IMAGES_DEFAULT_SELECTOR
from ..image_scraper.scraper import download_images
from ..profiles.manager import ProfileManager


class LogHandler(logging.Handler, QObject):
    """Forward log records to a Qt signal."""

    log_signal = Signal(str)

    def __init__(self) -> None:
        logging.Handler.__init__(self)
        QObject.__init__(self)

    def emit(self, record: logging.LogRecord) -> None:  # noqa: D401 - override
        self.log_signal.emit(self.format(record))


class ScrapeWorker(QThread):
    """Thread to run the image scraping."""

    progress = Signal(int, int)
    finished = Signal(dict)

    def __init__(
        self, url: str, css: str, folder: str, *, use_alt_json: bool = True
    ) -> None:
        super().__init__()
        self.url = url
        self.css = css or IMAGES_DEFAULT_SELECTOR
        self.folder = folder
        self.use_alt_json = use_alt_json

    def run(self) -> None:  # noqa: D401 - QThread API
        result = download_images(
            self.url,
            css_selector=self.css,
            parent_dir=self.folder,
            progress_callback=lambda c, t: self.progress.emit(c, t),
            use_alt_json=self.use_alt_json,
        )
        self.finished.emit(result)


class ScrapingImagesWidget(QWidget):
    """Widget visuel pour lancer un scraping d'images."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        self.log_handler = LogHandler()
        self.log_handler.setFormatter(logging.Formatter("%(message)s"))
        root_logger = logging.getLogger()
        root_logger.addHandler(self.log_handler)
        root_logger.setLevel(logging.INFO)

        self.worker: ScrapeWorker | None = None
        self.scrape_folder: Path | None = None
        self.profile_manager = ProfileManager()

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        # Input URL ------------------------------------------------------
        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("\ud83d\udcce Lien du site")
        self.url_edit.setStyleSheet("padding: 8px; border-radius: 6px;")
        main_layout.addWidget(self.url_edit)

        # Profile selector and destination folder -----------------------
        fields_layout = QHBoxLayout()
        fields_layout.setSpacing(10)

        self.profile_combo = QComboBox()
        self.profile_combo.addItems(sorted(self.profile_manager.profiles))
        fields_layout.addWidget(self.profile_combo)

        folder_container = QWidget()
        folder_layout = QHBoxLayout(folder_container)
        folder_layout.setContentsMargins(0, 0, 0, 0)
        folder_layout.setSpacing(0)

        self.folder_edit = QLineEdit()
        self.folder_edit.setPlaceholderText("\ud83d\udcc1 Destination images")
        self.folder_edit.setStyleSheet(
            "padding: 8px; border-top-left-radius: 6px;"
            " border-bottom-left-radius: 6px;"
        )
        folder_layout.addWidget(self.folder_edit)

        self.browse_btn = QPushButton("\ud83d\udcc1")
        self.browse_btn.setFixedWidth(30)
        self.browse_btn.clicked.connect(self.select_folder)
        self.browse_btn.setStyleSheet(
            "padding: 6px; border-top-right-radius: 6px;"
            " border-bottom-right-radius: 6px;"
        )
        folder_layout.addWidget(self.browse_btn)

        fields_layout.addWidget(folder_container)
        main_layout.addLayout(fields_layout)

        # Progress bar --------------------------------------------------
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.hide()
        main_layout.addWidget(self.progress_bar)

        # Launch button --------------------------------------------------
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        self.start_btn = QPushButton("\ud83d\ude80 LANCER LE SCRAPING")
        self.start_btn.setStyleSheet(
            """
            QPushButton {
                background-color: #2ecc71;
                color: white;
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #27ae60;
            }
            """
        )
        self.start_btn.clicked.connect(self.start_scraping)
        button_layout.addWidget(self.start_btn)
        button_layout.addStretch()

        main_layout.addLayout(button_layout)

        # Console -------------------------------------------------------
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setStyleSheet(
            "background-color: #212121; color: #00FF00; border-radius: 6px;"
        )
        self.log_handler.log_signal.connect(self.console.append)
        main_layout.addWidget(self.console)

    # ------------------------------------------------------------------
    def select_folder(self) -> None:
        folder = QFileDialog.getExistingDirectory(self, "Choisir un dossier")
        if folder:
            self.folder_edit.setText(folder)

    @Slot(str)
    def set_selected_profile(self, name: str) -> None:
        """Update the combo box to *name* if present."""
        index = self.profile_combo.findText(name)
        if index >= 0:
            self.profile_combo.setCurrentIndex(index)

    @Slot()
    def start_scraping(self) -> None:
        """Launch the scraping process in a background thread."""
        url_text = self.url_edit.text().strip()
        if not url_text:
            self.console.append("⚠️ URL manquante")
            return

        self.pending_urls = [u for u in url_text.split() if u]
        profile_name = self.profile_combo.currentText()
        profile = self.profile_manager.get_profile(profile_name)
        self.current_css = profile.css_selector if profile else IMAGES_DEFAULT_SELECTOR
        self.current_folder = self.folder_edit.text().strip() or "images"

        self.console.clear()
        self.console.append(f"Profil: {profile_name} - Sélecteur: {self.current_css}")
        self.progress_bar.setValue(0)
        self.progress_bar.show()
        self.start_btn.setEnabled(False)

        self._start_next_url()

    def _start_next_url(self) -> None:
        if not self.pending_urls:
            self.start_btn.setEnabled(True)
            return
        url = self.pending_urls.pop(0)
        self.console.append(url)
        self.worker = ScrapeWorker(url, self.current_css, self.current_folder)
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.scraping_finished)
        self.worker.start()

    @Slot(int, int)
    def update_progress(self, current: int, total: int) -> None:
        if total:
            pct = int(current / total * 100)
            self.console.append(f"Progression: {pct}%")
            self.progress_bar.setValue(pct)

    @Slot(dict)
    def scraping_finished(self, result: dict) -> None:
        self.scrape_folder = Path(result.get("folder", ""))
        self.console.append("✅ Terminé")
        if self.scrape_folder and self.scrape_folder.exists():
            QDesktopServices.openUrl(QUrl.fromLocalFile(str(self.scrape_folder)))
        self._start_next_url()
===== MOTEUR/scraping/widgets/variant_widget.py =====
from __future__ import annotations

import logging
from typing import Optional

from PySide6.QtCore import QThread, Signal, Slot
from PySide6.QtWidgets import (
    QHBoxLayout,
    QLineEdit,
    QPushButton,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from ..scraping_variantes import (
    VARIANT_DEFAULT_SELECTOR,
    extract_variants_with_images,
)


class VariantWorker(QThread):
    """Thread running the variant extraction."""

    finished = Signal(str, dict)

    def __init__(self, url: str, selector: str) -> None:
        super().__init__()
        self.url = url
        self.selector = selector

    def run(self) -> None:  # noqa: D401 - QThread API
        try:
            title, variants = extract_variants_with_images(self.url)
        except Exception as exc:  # pragma: no cover - network/driver issues
            logging.getLogger(__name__).error("%s", exc)
            self.finished.emit("", {})
            return
        self.finished.emit(title, variants)


class ScrapingVariantsWidget(QWidget):
    """Simple GUI to scrape product variants from a URL."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("Lien du produit")
        layout.addWidget(self.url_edit)

        self.selector_edit = QLineEdit(VARIANT_DEFAULT_SELECTOR)
        self.selector_edit.setPlaceholderText("Sélecteur CSS des variantes")
        layout.addWidget(self.selector_edit)

        start_row = QHBoxLayout()
        start_row.addStretch()
        self.start_btn = QPushButton("Lancer")
        self.start_btn.clicked.connect(self.start_scraping)
        start_row.addWidget(self.start_btn)
        start_row.addStretch()
        layout.addLayout(start_row)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        self.worker: VariantWorker | None = None

    # ------------------------------------------------------------------
    @Slot()
    def start_scraping(self) -> None:
        url = self.url_edit.text().strip()
        if not url:
            self.console.append("⚠️ URL manquante")
            return
        selector = self.selector_edit.text().strip() or VARIANT_DEFAULT_SELECTOR
        self.console.clear()
        self.start_btn.setEnabled(False)

        self.worker = VariantWorker(url, selector)
        self.worker.finished.connect(self.scraping_finished)
        self.worker.start()

    @Slot(str, dict)
    def scraping_finished(self, title: str, variants: dict[str, str]) -> None:
        if title:
            self.console.append(f"Produit: {title}")
            for name, link in variants.items():
                self.console.append(f"- {name} : {link}")
        self.start_btn.setEnabled(True)

===== MOTEUR/scraping/widgets/variant_comparison_widget.py =====

from __future__ import annotations

import re
from pathlib import Path
from typing import Optional

from PySide6.QtCore import QThread, Signal, Slot
from PySide6.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)

from ..scraping_variantes import extract_variants_with_images


class VariantWorker(QThread):
    """Fetch variant images from competitor site in a thread."""

    finished = Signal(dict)

    def __init__(self, url: str) -> None:
        super().__init__()
        self.url = url

    def run(self) -> None:  # noqa: D401 - QThread API
        try:
            _, variants = extract_variants_with_images(self.url)
        except Exception:  # pragma: no cover - network/driver issues
            variants = {}
        self.finished.emit(variants)


class VariantComparisonWidget(QWidget):
    """Compare WooCommerce image URLs with competitor ones."""

    ALLOWED_EXTENSIONS = {".webp", ".jpg", ".jpeg", ".png"}

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.profile_manager = ProfileManager()

        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("Lien produit concurrent")
        layout.addWidget(self.url_edit)

        self.profile_combo = QComboBox()
        self.profile_combo.addItems(sorted(self.profile_manager.profiles))
        layout.addWidget(self.profile_combo)

        folder_row = QHBoxLayout()
        self.folder_edit = QLineEdit()
        self.folder_edit.setPlaceholderText("Dossier images")
        folder_row.addWidget(self.folder_edit)
        self.browse_btn = QPushButton("\ud83d\udcc1")
        folder_row.addWidget(self.browse_btn)
        layout.addLayout(folder_row)

        self.folder_btn = QPushButton("Choisir le dossier d'images")
        self.folder_btn.clicked.connect(self.choose_folder)
        layout.addWidget(self.folder_btn)

        actions = QHBoxLayout()
        self.start_btn = QPushButton("Comparer")
        self.start_btn.clicked.connect(self.start_comparison)
        actions.addWidget(self.start_btn)
        actions.addStretch()
        layout.addLayout(actions)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Variante",
            "Lien Woo",
            "Lien Concurrent",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        self.folder_path: Path | None = None
        self.worker: VariantWorker | None = None

    # ------------------------------------------------------------------
    def choose_folder(self) -> None:
        folder = QFileDialog.getExistingDirectory(self, "Sélectionner un dossier")
        if folder:
            self.folder_path = Path(folder)
            self.folder_btn.setText(f"Dossier : {self.folder_path.name}")

    def valid_date(self, text: str) -> bool:
        return bool(re.fullmatch(r"\d{4}/\d{2}", text))

    def generate_woo_links(self) -> list[str]:
        if not self.folder_path:
            return []

        date_path = self.date_edit.text().strip()
        if not self.valid_date(date_path):
            return []

        base_url = self.domain_edit.text().strip().rstrip("/")
        links: list[str] = []
        for file in sorted(self.folder_path.iterdir()):
            if file.suffix.lower() in self.ALLOWED_EXTENSIONS:
                links.append(
                    f"{base_url}/wp-content/uploads/{date_path}/{file.name}"
                )
        return links

    @Slot()
    def start_comparison(self) -> None:
        url = self.url_edit.text().strip()
        if not url or not self.folder_path:
            return

        self.start_btn.setEnabled(False)
        self.worker = VariantWorker(url)
        self.worker.finished.connect(self.comparison_finished)
        self.worker.start()

    @Slot(dict)
    def comparison_finished(self, variants: dict[str, str]) -> None:
        woo_links = self.generate_woo_links()
        self.table.setRowCount(0)
        for idx, (name, comp_link) in enumerate(variants.items()):
            row = self.table.rowCount()
            self.table.insertRow(row)
            woo_link = woo_links[idx] if idx < len(woo_links) else ""
            self.table.setItem(row, 0, QTableWidgetItem(name))
            self.table.setItem(row, 1, QTableWidgetItem(woo_link))
            self.table.setItem(row, 2, QTableWidgetItem(comp_link))
        self.start_btn.setEnabled(True)
===== MOTEUR/scraping/widgets/combined_scrape_widget.py =====
from __future__ import annotations

import re
from pathlib import Path
from typing import Optional

from PySide6.QtCore import Slot
from PySide6.QtWidgets import (
    QLabel,
    QLineEdit,
    QPushButton,
    QProgressBar,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)

from .scraping_widget import ScrapeWorker
from ..scraping_variantes import extract_variants_with_images
from ..image_scraper.constants import IMAGES_DEFAULT_SELECTOR
from ..image_scraper.rename import clean_filename


def find_woo_link(name: str, links: list[str]) -> str | None:
    """Return and remove the first link whose filename contains *name*."""
    key = clean_filename(name)
    for idx, url in enumerate(list(links)):
        if key and key in clean_filename(Path(url).stem):
            return links.pop(idx)
    return None


class CombinedScrapeWidget(QWidget):
    """Download images, extract variants and generate Woo links."""

    ALLOWED_EXTENSIONS = {".webp", ".jpg", ".jpeg", ".png"}

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        # widgets setup (url, profile selection, folder, console, table)
        # a copy button allows to copy the console output and a log handler
        # redirects Python logs to the text area

    def valid_date(self, text: str) -> bool:
        return bool(re.fullmatch(r"\d{4}/\d{2}", text))

    def generate_woo_links(self) -> list[str]:
        if not self.scrape_folder:
            return []
        date_path = self.date.strip()
        if not self.valid_date(date_path):
            return []
        base_url = self.domain.strip().rstrip("/")
        links = [
            f"{base_url}/wp-content/uploads/{date_path}/{f.name}"
            for f in sorted(self.scrape_folder.iterdir())
            if f.suffix.lower() in self.ALLOWED_EXTENSIONS
        ]
        return links

    def populate_table(self, variants: dict[str, str]) -> None:
        woo_links = self.generate_woo_links()
        remaining = list(woo_links)
        items = list(variants.items())
        self.table.setRowCount(0)

        for name, comp in items:
            woo = find_woo_link(name, remaining)
            if woo is None and remaining:
                woo = remaining.pop(0)
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(name))
            self.table.setItem(row, 1, QTableWidgetItem(woo or ""))
            self.table.setItem(row, 2, QTableWidgetItem(comp))

        for woo in remaining:
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(""))
            self.table.setItem(row, 1, QTableWidgetItem(woo))
            self.table.setItem(row, 2, QTableWidgetItem(""))

    def export_csv(self) -> None:
        path, _ = QFileDialog.getSaveFileName(
            self, "Exporter CSV", str(Path.home()), "CSV (*.csv)"
        )
        if not path:
            return
        with open(path, "w", newline="", encoding="utf-8") as fh:
            writer = csv.writer(fh)
            writer.writerow(["Variante", "Lien Woo"])
            for i in range(self.table.rowCount()):
                var = self.table.item(i, 0)
                woo = self.table.item(i, 1)
                writer.writerow([
                    var.text() if var else "",
                    woo.text() if woo else "",
                ])

# Woo links matched to variants by keyword in file names

===== MOTEUR/scraping/widgets/settings_widget.py =====

from __future__ import annotations

from typing import Iterable

from PySide6.QtCore import Signal
from PySide6.QtWidgets import QCheckBox, QVBoxLayout, QWidget


class ScrapingSettingsWidget(QWidget):
    """Tab allowing to enable or disable scraping modules."""

    module_toggled = Signal(str, bool)

    def __init__(self, modules: Iterable[str], parent: QWidget | None = None) -> None:
        super().__init__(parent)
        layout = QVBoxLayout(self)
        self.checkboxes: dict[str, QCheckBox] = {}
        for name in modules:
            cb = QCheckBox(name)
            cb.setChecked(True)
            cb.toggled.connect(lambda state, n=name: self.module_toggled.emit(n, state))
            layout.addWidget(cb)
            self.checkboxes[name] = cb
        layout.addStretch()


===== MOTEUR/scraping/scraping_variantes.py =====
"""Extract product variants from an e-commerce webpage."""

from __future__ import annotations

import argparse
import logging
import time
from pathlib import Path

from selenium.common.exceptions import NoSuchElementException, TimeoutException
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

from MOTEUR.scraping.image_scraper.driver import setup_driver

# Default CSS selector to locate variant elements
VARIANT_DEFAULT_SELECTOR = ".variant-picker__option-values input[type='radio']"


def extract_variants(url: str, selector: str = VARIANT_DEFAULT_SELECTOR) -> tuple[str, list[str]]:
    """Return product title and list of variant names found on *url*."""
    if not url.lower().startswith(("http://", "https://")):
        raise ValueError("URL must start with http:// or https://")

    driver = setup_driver()
    try:
        logging.info("\U0001f310 Chargement de la page %s", url)
        driver.get(url)
        wait = WebDriverWait(driver, 10)
        try:
            wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
        except TimeoutException as exc:
            raise TimeoutException(
                f"Timeout waiting for elements with selector {selector}"
            ) from exc

        title = driver.find_element(By.CSS_SELECTOR, "h1").text.strip()
        elems = driver.find_elements(By.CSS_SELECTOR, selector)
        variants: list[str] = []
        for elem in elems:
            # Some shops hide the text inside the <input> element. In this
            # case the variant name is stored in the ``value`` attribute or the
            # associated label.  Fallback to ``value`` when ``elem.text`` is
            # empty to ensure variants are correctly captured.
            name = elem.text.strip()
            if not name:
                name = elem.get_attribute("value") or ""
            if name:
                variants.append(name)
        logging.info("\u2714\ufe0f %d variante(s) d\u00e9tect\u00e9e(s)", len(variants))
        return title, variants
    finally:
        driver.quit()


def extract_variants_with_images(url: str) -> tuple[str, dict[str, str]]:
    """Return product title and a mapping of variant name to image URL."""
    if not url.lower().startswith(("http://", "https://")):
        raise ValueError("URL must start with http:// or https://")

    driver = setup_driver()
    try:
        logging.info("\U0001f310 Chargement de la page %s", url)
        driver.get(url)
        wait = WebDriverWait(driver, 10)
        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "h1")))
        title = driver.find_element(By.CSS_SELECTOR, "h1").text.strip()

        container = driver.find_element(By.CSS_SELECTOR, ".variant-picker__option-values")
        inputs = container.find_elements(By.CSS_SELECTOR, "input[type='radio'].sr-only")

        results: dict[str, str] = {}
        for inp in inputs:
            name = inp.get_attribute("value")
            if not name or name in results:
                continue

            img_elem = driver.find_element(By.CSS_SELECTOR, ".product-gallery__media.is-selected img")
            old_src = img_elem.get_attribute("src")

            if inp.get_attribute("checked") is None:
                driver.execute_script("arguments[0].click();", inp)
                try:
                    wait.until(
                        lambda d: d.find_element(By.CSS_SELECTOR, ".product-gallery__media.is-selected img").get_attribute("src") != old_src
                    )
                except TimeoutException:
                    logging.warning("No image change detected for %s", name)
                img_elem = driver.find_element(By.CSS_SELECTOR, ".product-gallery__media.is-selected img")

            src = img_elem.get_attribute("src")
            if src.startswith("//"):
                src = "https:" + src
            results[name] = src
            logging.info("%s -> %s", name, src)

        return title, results
    finally:
        driver.quit()


def save_to_file(title: str, variants: list[str], path: Path) -> None:
    """Write *title* and *variants* into *path* as a single line."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write(f"{title}\t{', '.join(variants)}\n")
    logging.info("\U0001f4be Variantes enregistr\u00e9es dans %s", path)


def save_images_to_file(title: str, variants: dict[str, str], path: Path) -> None:
    """Write *title* and variant/image pairs into *path*."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write(f"{title}\n")
        for name, img in variants.items():
            fh.write(f"{name} : {img}\n")
    logging.info("\U0001f4be Variantes enregistr\u00e9es dans %s", path)


def scrape_variants(url: str, selector: str, output: Path, *, with_images: bool = False) -> None:
    """High-level helper combining extraction and saving.

    When *with_images* is ``True`` the function also grabs the image URL for
    each variant and stores the mapping in ``output``.
    """
    if with_images:
        title, variants = extract_variants_with_images(url)
        save_images_to_file(title, variants, output)
    else:
        title, variants = extract_variants(url, selector)
        save_to_file(title, variants, output)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Extrait le titre du produit et la liste des variantes."
    )
    parser.add_argument(
        "url", nargs="?", help="URL du produit (si absent, demande \u00e0 l'ex\u00e9cution)"
    )
    parser.add_argument(
        "-s",
        "--selector",
        default=VARIANT_DEFAULT_SELECTOR,
        help="S\u00e9lecteur CSS des variantes",
    )
    parser.add_argument(
        "-o", "--output", default="variants.txt", help="Fichier de sortie"
    )
    parser.add_argument(
        "-i",
        "--images",
        action="store_true",
        help="Inclure les URL d'images des variantes",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
        help="Niveau de logging",
    )
    args = parser.parse_args()

    if not args.url:
        args.url = input("URL du produit : ").strip()

    logging.basicConfig(level=getattr(logging, args.log_level), format="%(levelname)s: %(message)s")

    try:
        scrape_variants(args.url, args.selector, Path(args.output), with_images=args.images)
    except (NoSuchElementException, TimeoutException, ValueError) as exc:
        logging.error("%s", exc)


if __name__ == "__main__":
    main()

===== MOTEUR/scraping/widgets/__init__.py =====
from .scraping_widget import ScrapingImagesWidget
from .profile_widget import ProfileWidget
from .variant_widget import ScrapingVariantsWidget
from .woo_url_widget import WooImageURLWidget
from .variant_comparison_widget import VariantComparisonWidget
from .combined_scrape_widget import CombinedScrapeWidget
from .settings_widget import ScrapingSettingsWidget
from .scrap_widget import ScrapWidget

===== MOTEUR/scraping/widgets/combined_scrape_widget.py =====
from __future__ import annotations

import re
from pathlib import Path
from typing import Optional

import logging
from PySide6.QtCore import Slot
from PySide6.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QLineEdit,
    QPushButton,
    QProgressBar,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
    QTextEdit,
    QComboBox,
    QMessageBox,
    QApplication,
)
import csv

from .scraping_widget import ScrapeWorker, LogHandler
from ..scraping_variantes import extract_variants_with_images
from ..image_scraper.constants import IMAGES_DEFAULT_SELECTOR
from ..image_scraper.rename import clean_filename
from ..profiles.manager import ProfileManager


def find_woo_link(name: str, links: list[str]) -> str | None:
    """Return and remove the first link whose filename contains *name*."""
    key = clean_filename(name)
    for idx, url in enumerate(list(links)):
        filename = Path(url).stem
        if key and key in clean_filename(filename):
            return links.pop(idx)
    return None


class CombinedScrapeWidget(QWidget):
    """Download images, extract variants and generate Woo links."""

    ALLOWED_EXTENSIONS = {".webp", ".jpg", ".jpeg", ".png"}

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.profile_manager = ProfileManager()
        self.pending_urls: list[str] = []
        self.current_url: str = ""

        self.profile_combo = QComboBox()
        self.profile_combo.addItems(sorted(self.profile_manager.profiles))
        layout.addWidget(self.profile_combo)

        folder_row = QHBoxLayout()
        self.folder_edit = QLineEdit()
        self.folder_edit.setPlaceholderText("Dossier images")
        folder_row.addWidget(self.folder_edit)
        self.browse_btn = QPushButton("\ud83d\udcc1")
        self.browse_btn.clicked.connect(self.select_folder)
        folder_row.addWidget(self.browse_btn)
        layout.addLayout(folder_row)

        self.start_btn = QPushButton("Lancer")
        self.start_btn.clicked.connect(self.start_process)
        layout.addWidget(self.start_btn)

        self.progress = QProgressBar()
        self.progress.setRange(0, 100)
        self.progress.hide()
        layout.addWidget(self.progress)

        self.log_handler = LogHandler()
        self.log_handler.setFormatter(logging.Formatter("%(message)s"))
        logging.getLogger().addHandler(self.log_handler)
        logging.getLogger().setLevel(logging.INFO)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.log_handler.log_signal.connect(self.console.append)
        layout.addWidget(self.console)

        copy_btn = QPushButton("Copier")
        copy_btn.clicked.connect(self.copy_console)
        layout.addWidget(copy_btn)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Variante",
            "Lien Woo",
            "Lien Concurrent",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        btn_row = QHBoxLayout()
        export_btn = QPushButton("Exporter CSV")
        export_btn.clicked.connect(self.export_csv)
        btn_row.addStretch()
        btn_row.addWidget(export_btn)
        layout.addLayout(btn_row)

        self.scrape_folder: Path | None = None
        self.worker: ScrapeWorker | None = None
        self.domain: str = ""
        self.date: str = ""

    # ------------------------------------------------------------------
    def valid_date(self, text: str) -> bool:
        return bool(re.fullmatch(r"\d{4}/\d{2}", text))

    def generate_woo_links(self) -> list[str]:
        if not self.scrape_folder:
            return []
        date_path = self.date.strip()
        if not self.valid_date(date_path):
            return []
        base_url = self.domain.strip().rstrip("/")
        links: list[str] = []
        for file in sorted(self.scrape_folder.iterdir()):
            if file.suffix.lower() in self.ALLOWED_EXTENSIONS:
                links.append(
                    f"{base_url}/wp-content/uploads/{date_path}/{file.name}"
                )
        return links


    def populate_table(self, variants: dict[str, str]) -> None:
        woo_links = self.generate_woo_links()
        remaining = list(woo_links)
        items = list(variants.items())
        self.table.setRowCount(0)

        for name, comp in items:
            woo = find_woo_link(name, remaining)
            if woo is None and remaining:
                woo = remaining.pop(0)
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(name))
            self.table.setItem(row, 1, QTableWidgetItem(woo or ""))
            self.table.setItem(row, 2, QTableWidgetItem(comp))

        for woo in remaining:
            row = self.table.rowCount()
            self.table.insertRow(row)
            self.table.setItem(row, 0, QTableWidgetItem(""))
            self.table.setItem(row, 1, QTableWidgetItem(woo))
            self.table.setItem(row, 2, QTableWidgetItem(""))

    def export_csv(self) -> None:
        path, _ = QFileDialog.getSaveFileName(
            self, "Exporter CSV", str(Path.home()), "CSV (*.csv)"
        )
        if not path:
            return
        with open(path, "w", newline="", encoding="utf-8") as fh:
            writer = csv.writer(fh)
            writer.writerow(["Variante", "Lien Woo"])
            for row in range(self.table.rowCount()):
                var_item = self.table.item(row, 0)
                woo_item = self.table.item(row, 1)
                writer.writerow([
                    var_item.text() if var_item else "",
                    woo_item.text() if woo_item else "",
                ])

    def copy_console(self) -> None:
        clipboard = QApplication.clipboard()
        clipboard.setText(self.console.toPlainText())

    @Slot()
    def start_process(self) -> None:
        profile_name = self.profile_combo.currentText()
        profile = self.profile_manager.get_profile(profile_name)
        url_file = profile.url_file if profile else ""
        urls: list[str] = []
        if url_file:
            try:
                text = Path(url_file).read_text(encoding="utf-8-sig")
                urls = [u.strip() for u in text.splitlines() if u.strip()]
            except Exception:
                urls = []
        if not urls:
            return

        self.pending_urls = urls
        self.css = profile.css_selector if profile else IMAGES_DEFAULT_SELECTOR
        self.domain = profile.domain if profile else "https://www.planetebob.fr"
        self.date = profile.date if profile else "2025/07"
        self.folder = self.folder_edit.text().strip() or "images"

        self.console.clear()
        self.console.append(f"Profil: {profile_name}")
        self.table.setRowCount(0)
        self.start_btn.setEnabled(False)
        self.progress.setValue(0)
        self.progress.show()
        self._start_next_url()

    def _start_next_url(self) -> None:
        if not self.pending_urls:
            return
        url = self.pending_urls.pop(0)
        self.current_url = url
        self.console.append(url)
        self.worker = ScrapeWorker(url, self.css, self.folder)
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.scrape_finished)
        self.worker.start()

    @Slot(int, int)
    def update_progress(self, current: int, total: int) -> None:
        if total:
            pct = int(current / total * 33)
            self.progress.setValue(pct)

    @Slot(dict)
    def scrape_finished(self, result: dict) -> None:
        self.scrape_folder = Path(result.get("folder", ""))
        self.progress.setValue(33)
        self.console.append("\U0001f50d Récupération des variantes...")
        try:
            _, variants = extract_variants_with_images(self.current_url)
        except Exception:  # pragma: no cover - network issues
            variants = {}
        self.progress.setValue(66)
        self.console.append("\U0001f517 Génération des liens...")
        self.populate_table(variants)
        if self.pending_urls:
            self._start_next_url()
        else:
            self.progress.setValue(100)
            self.console.append("✅ Terminé")
            self.progress.hide()
            self.start_btn.setEnabled(True)
            QMessageBox.information(self, "Scraping", "Op\u00e9ration termin\u00e9e")

    # ------------------------------------------------------------------
    def select_folder(self) -> None:
        folder = QFileDialog.getExistingDirectory(self, "Choisir un dossier")
        if folder:
            self.folder_edit.setText(folder)

    @Slot()
    def refresh_profiles(self) -> None:
        self.profile_manager = ProfileManager()
        self.profile_combo.clear()
        self.profile_combo.addItems(sorted(self.profile_manager.profiles))
        if self.profile_combo.count():
            self.set_selected_profile(self.profile_combo.currentText())

    @Slot(str)
    def set_selected_profile(self, name: str) -> None:
        index = self.profile_combo.findText(name)
        if index >= 0:
            self.profile_combo.setCurrentIndex(index)
        # No URL field anymore

===== MOTEUR/scraping/widgets/profile_widget.py =====
from __future__ import annotations

from typing import Optional
from pathlib import Path

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QListWidget,
    QLineEdit,
    QPushButton,
    QMessageBox,
    QFileDialog,
)
from PySide6.QtCore import Signal

from ..profiles.manager import ProfileManager


class ProfileWidget(QWidget):
    """Widget to manage scraping profiles."""

    profile_chosen = Signal(str)
    profiles_updated = Signal()

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        self.manager = ProfileManager()

        main_layout = QVBoxLayout(self)

        # List of existing profiles
        self.profile_list = QListWidget()
        self.profile_list.addItems(sorted(self.manager.profiles))
        self.profile_list.currentItemChanged.connect(self.profile_selected)
        main_layout.addWidget(self.profile_list)

        # Fields to edit profile
        form_layout = QHBoxLayout()
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Nom du profil")
        form_layout.addWidget(self.name_edit)

        self.css_edit = QLineEdit()
        self.css_edit.setPlaceholderText("Sélecteur CSS")
        form_layout.addWidget(self.css_edit)

        self.domain_edit = QLineEdit()
        self.domain_edit.setPlaceholderText("Domaine")
        form_layout.addWidget(self.domain_edit)

        self.date_edit = QLineEdit()
        self.date_edit.setPlaceholderText("Date YYYY/MM")
        form_layout.addWidget(self.date_edit)

        url_container = QHBoxLayout()
        self.url_file_edit = QLineEdit()
        self.url_file_edit.setPlaceholderText("Fichier URL")
        url_container.addWidget(self.url_file_edit)
        self.url_file_btn = QPushButton("...")
        self.url_file_btn.clicked.connect(self.select_url_file)
        url_container.addWidget(self.url_file_btn)
        form_layout.addLayout(url_container)

        main_layout.addLayout(form_layout)

        # Buttons
        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_profile)
        btn_layout.addWidget(self.add_btn)

        self.save_btn = QPushButton("Enregistrer")
        self.save_btn.clicked.connect(self.save_profile)
        btn_layout.addWidget(self.save_btn)

        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.delete_profile)
        btn_layout.addWidget(self.del_btn)

        self.use_btn = QPushButton("Utiliser")
        self.use_btn.clicked.connect(self.use_profile)
        btn_layout.addWidget(self.use_btn)

        main_layout.addLayout(btn_layout)

    # ------------------------------------------------------------------
    def profile_selected(self, current, previous) -> None:  # noqa: D401
        if current:
            name = current.text()
            self.name_edit.setText(name)
            profile = self.manager.get_profile(name)
            css = profile.css_selector if profile else ""
            self.css_edit.setText(css)
            self.domain_edit.setText(profile.domain if profile else "")
            self.date_edit.setText(profile.date if profile else "")
            self.url_file_edit.setText(profile.url_file if profile else "")

    def add_profile(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Profil", "Nom manquant")
            return
        css = self.css_edit.text().strip()
        domain = self.domain_edit.text().strip()
        date = self.date_edit.text().strip()
        url_file = self.url_file_edit.text().strip()
        if name in self.manager.profiles:
            QMessageBox.information(self, "Profil", "Ce profil existe déjà")
            return
        self.manager.add_or_update_profile(name, css, domain, date, url_file)
        self.profile_list.addItem(name)
        self.profile_list.setCurrentRow(self.profile_list.count() - 1)
        self.profiles_updated.emit()

    def save_profile(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            QMessageBox.warning(self, "Profil", "Nom manquant")
            return
        css = self.css_edit.text().strip()
        domain = self.domain_edit.text().strip()
        date = self.date_edit.text().strip()
        url_file = self.url_file_edit.text().strip()
        self.manager.add_or_update_profile(name, css, domain, date, url_file)
        # Ensure the list has this profile
        for i in range(self.profile_list.count()):
            if self.profile_list.item(i).text() == name:
                break
        else:
            self.profile_list.addItem(name)
        items = [
            self.profile_list.item(i).text()
            for i in range(self.profile_list.count())
        ]
        self.profile_list.setCurrentRow(items.index(name))
        self.profiles_updated.emit()

    def delete_profile(self) -> None:
        name = self.name_edit.text().strip()
        if not name:
            return
        if name in self.manager.profiles:
            self.manager.remove_profile(name)
        for i in range(self.profile_list.count()):
            if self.profile_list.item(i).text() == name:
                self.profile_list.takeItem(i)
                break
        self.name_edit.clear()
        self.css_edit.clear()
        self.domain_edit.clear()
        self.date_edit.clear()
        self.url_file_edit.clear()
        if self.profile_list.count():
            self.profile_list.setCurrentRow(0)
        self.profiles_updated.emit()

    def use_profile(self) -> None:
        """Emit the currently selected profile name."""
        name = self.name_edit.text().strip()
        if name:
            self.profile_chosen.emit(name)

    def select_url_file(self) -> None:
        """Open a file dialog to select a text file containing URLs."""
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Choisir un fichier",
            str(Path.home()),
            "Text files (*.txt);;All files (*)",
        )
        if path:
            self.url_file_edit.setText(path)

===== MOTEUR/scraping/widgets/scrap_widget.py =====
from __future__ import annotations

from typing import Optional

from PySide6.QtWidgets import QTabWidget, QVBoxLayout, QWidget

from .scraping_widget import ScrapingImagesWidget
from .variant_widget import ScrapingVariantsWidget
from .woo_url_widget import WooImageURLWidget
from .variant_comparison_widget import VariantComparisonWidget
from .combined_scrape_widget import CombinedScrapeWidget


class ScrapWidget(QWidget):
    """Widget combinant le scraping d'images et de variantes."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.tabs = QTabWidget()

        self.images_widget = ScrapingImagesWidget()
        self.variants_widget = ScrapingVariantsWidget()
        self.woo_widget = WooImageURLWidget()
        self.compare_widget = VariantComparisonWidget()
        self.combined_widget = CombinedScrapeWidget()

        self.modules_order = [
            "Images",
            "Variantes",
            "Liens Woo",
            "Comparaison",
            "Tout-en-un",
        ]

        self.modules = {
            "Images": self.images_widget,
            "Variantes": self.variants_widget,
            "Liens Woo": self.woo_widget,
            "Comparaison": self.compare_widget,
            "Tout-en-un": self.combined_widget,
        }

        for name in self.modules_order:
            self.tabs.addTab(self.modules[name], name)

        # Settings widget will be handled externally

        layout.addWidget(self.tabs)

    # ------------------------------------------------------------------
    def toggle_module(self, name: str, enabled: bool) -> None:
        """Show or hide the tab corresponding to *name*."""
        widget = self.modules.get(name)
        if not widget:
            return
        current_index = self.tabs.indexOf(widget)
        if enabled and current_index == -1:
            pos = 0
            for n in self.modules_order:
                if n == name:
                    break
                if self.tabs.indexOf(self.modules[n]) != -1:
                    pos += 1
            self.tabs.insertTab(pos, widget, name)
        elif not enabled and current_index != -1:
            self.tabs.removeTab(current_index)

===== MOTEUR/scraping/widgets/scraping_widget.py =====
from __future__ import annotations

import logging
from pathlib import Path
from typing import Optional

from PySide6.QtCore import QObject, QThread, QUrl, Signal, Slot
from PySide6.QtGui import QDesktopServices
from PySide6.QtWidgets import (
    QComboBox,
    QFileDialog,
    QHBoxLayout,
    QLineEdit,
    QProgressBar,
    QPushButton,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from ..image_scraper.constants import IMAGES_DEFAULT_SELECTOR
from ..image_scraper.scraper import download_images
from ..profiles.manager import ProfileManager


class LogHandler(logging.Handler, QObject):
    """Forward log records to a Qt signal."""

    log_signal = Signal(str)

    def __init__(self) -> None:
        logging.Handler.__init__(self)
        QObject.__init__(self)

    def emit(self, record: logging.LogRecord) -> None:  # noqa: D401 - override
        self.log_signal.emit(self.format(record))


class ScrapeWorker(QThread):
    """Thread to run the image scraping."""

    progress = Signal(int, int)
    finished = Signal(dict)

    def __init__(
        self, url: str, css: str, folder: str, *, use_alt_json: bool = True
    ) -> None:
        super().__init__()
        self.url = url
        self.css = css or IMAGES_DEFAULT_SELECTOR
        self.folder = folder
        self.use_alt_json = use_alt_json

    def run(self) -> None:  # noqa: D401 - QThread API
        """Execute the scraping in a background thread."""
        try:
            result = download_images(
                self.url,
                css_selector=self.css,
                parent_dir=self.folder,
                progress_callback=lambda c, t: self.progress.emit(c, t),
                use_alt_json=self.use_alt_json,
            )
        except FileNotFoundError as exc:  # chromedriver missing
            logging.getLogger(__name__).error(
                "ChromeDriver not found: install it or specify chromedriver_path"
            )
            result = {"folder": Path(), "first_image": None}
        self.finished.emit(result)


class ScrapingImagesWidget(QWidget):
    """Widget visuel pour lancer un scraping d'images."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        self.log_handler = LogHandler()
        self.log_handler.setFormatter(logging.Formatter("%(message)s"))
        root_logger = logging.getLogger()
        root_logger.addHandler(self.log_handler)
        root_logger.setLevel(logging.INFO)

        self.worker: ScrapeWorker | None = None
        self.scrape_folder: Path | None = None
        self.profile_manager = ProfileManager()
        self.pending_urls: list[str] = []
        self.current_css = ""
        self.current_folder = ""

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        # Input URL ------------------------------------------------------
        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("\ud83d\udcce Lien du site")
        self.url_edit.setStyleSheet("padding: 8px; border-radius: 6px;")
        main_layout.addWidget(self.url_edit)

        # Profile selector and destination folder -----------------------
        fields_layout = QHBoxLayout()
        fields_layout.setSpacing(10)

        self.profile_combo = QComboBox()
        self.profile_combo.addItems(sorted(self.profile_manager.profiles))
        fields_layout.addWidget(self.profile_combo)

        folder_container = QWidget()
        folder_layout = QHBoxLayout(folder_container)
        folder_layout.setContentsMargins(0, 0, 0, 0)
        folder_layout.setSpacing(0)

        self.folder_edit = QLineEdit()
        self.folder_edit.setPlaceholderText("\ud83d\udcc1 Destination images")
        self.folder_edit.setStyleSheet(
            "padding: 8px; border-top-left-radius: 6px;"
            " border-bottom-left-radius: 6px;"
        )
        folder_layout.addWidget(self.folder_edit)

        self.browse_btn = QPushButton("\ud83d\udcc1")
        self.browse_btn.setFixedWidth(30)
        self.browse_btn.clicked.connect(self.select_folder)
        self.browse_btn.setStyleSheet(
            "padding: 6px; border-top-right-radius: 6px;"
            " border-bottom-right-radius: 6px;"
        )
        folder_layout.addWidget(self.browse_btn)

        fields_layout.addWidget(folder_container)
        main_layout.addLayout(fields_layout)

        # Progress bar --------------------------------------------------
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.hide()
        main_layout.addWidget(self.progress_bar)

        # Launch button --------------------------------------------------
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        self.start_btn = QPushButton("\ud83d\ude80 LANCER LE SCRAPING")
        self.start_btn.setStyleSheet(
            """
            QPushButton {
                background-color: #2ecc71;
                color: white;
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #27ae60;
            }
            """
        )
        self.start_btn.clicked.connect(self.start_scraping)
        button_layout.addWidget(self.start_btn)
        button_layout.addStretch()

        main_layout.addLayout(button_layout)

        # Console -------------------------------------------------------
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setStyleSheet(
            "background-color: #212121; color: #00FF00; border-radius: 6px;"
        )
        self.log_handler.log_signal.connect(self.console.append)
        main_layout.addWidget(self.console)

    # ------------------------------------------------------------------
    @Slot()
    def refresh_profiles(self) -> None:
        """Reload profiles and update the combo box."""
        self.profile_manager = ProfileManager()
        self.profile_combo.clear()
        self.profile_combo.addItems(sorted(self.profile_manager.profiles))

    def select_folder(self) -> None:
        folder = QFileDialog.getExistingDirectory(self, "Choisir un dossier")
        if folder:
            self.folder_edit.setText(folder)

    @Slot(str)
    def set_selected_profile(self, name: str) -> None:
        """Update the combo box to *name* if present."""
        index = self.profile_combo.findText(name)
        if index >= 0:
            self.profile_combo.setCurrentIndex(index)

    @Slot()
    def start_scraping(self) -> None:
        """Launch the scraping process in a background thread."""
        url_text = self.url_edit.text().strip()
        if not url_text:
            self.console.append("⚠️ URL manquante")
            return

        self.pending_urls = [u for u in url_text.split() if u]
        profile_name = self.profile_combo.currentText()
        profile = self.profile_manager.get_profile(profile_name)
        self.current_css = profile.css_selector if profile else IMAGES_DEFAULT_SELECTOR
        self.current_folder = self.folder_edit.text().strip() or "images"

        self.console.clear()
        self.console.append(f"Profil: {profile_name} - Sélecteur: {self.current_css}")
        self.progress_bar.setValue(0)
        self.progress_bar.show()
        self.start_btn.setEnabled(False)

        self._start_next_url()

    def _start_next_url(self) -> None:
        if not self.pending_urls:
            self.start_btn.setEnabled(True)
            return
        url = self.pending_urls.pop(0)
        self.console.append(url)
        self.worker = ScrapeWorker(url, self.current_css, self.current_folder)
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.scraping_finished)
        self.worker.start()

    @Slot(int, int)
    def update_progress(self, current: int, total: int) -> None:
        if total:
            pct = int(current / total * 100)
            self.console.append(f"Progression: {pct}%")
            self.progress_bar.setValue(pct)

    @Slot(dict)
    def scraping_finished(self, result: dict) -> None:
        self.scrape_folder = Path(result.get("folder", ""))
        self.console.append("✅ Terminé")
        if self.scrape_folder and self.scrape_folder.exists():
            QDesktopServices.openUrl(QUrl.fromLocalFile(str(self.scrape_folder)))
        self._start_next_url()

===== MOTEUR/scraping/widgets/settings_widget.py =====
from __future__ import annotations

from typing import Iterable

from PySide6.QtCore import Signal
from PySide6.QtWidgets import QCheckBox, QVBoxLayout, QWidget


class ScrapingSettingsWidget(QWidget):
    """Tab allowing to enable or disable scraping modules."""

    module_toggled = Signal(str, bool)

    def __init__(self, modules: Iterable[str], parent: QWidget | None = None) -> None:
        super().__init__(parent)
        layout = QVBoxLayout(self)
        self.checkboxes: dict[str, QCheckBox] = {}
        for name in modules:
            cb = QCheckBox(name)
            cb.setChecked(True)
            cb.toggled.connect(lambda state, n=name: self.module_toggled.emit(n, state))
            layout.addWidget(cb)
            self.checkboxes[name] = cb

        layout.addStretch()

===== MOTEUR/scraping/widgets/variant_comparison_widget.py =====
from __future__ import annotations

import re
from pathlib import Path
from typing import Optional

from PySide6.QtCore import QThread, Signal, Slot
from PySide6.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)

from ..scraping_variantes import extract_variants_with_images


class VariantWorker(QThread):
    """Fetch variant images from competitor site in a thread."""

    finished = Signal(dict)

    def __init__(self, url: str) -> None:
        super().__init__()
        self.url = url

    def run(self) -> None:  # noqa: D401 - QThread API
        try:
            _, variants = extract_variants_with_images(self.url)
        except Exception:  # pragma: no cover - network/driver issues
            variants = {}
        self.finished.emit(variants)


class VariantComparisonWidget(QWidget):
    """Compare WooCommerce image URLs with competitor ones."""

    ALLOWED_EXTENSIONS = {".webp", ".jpg", ".jpeg", ".png"}

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("Lien produit concurrent")
        layout.addWidget(self.url_edit)

        self.domain_label = QLabel("Domaine WooCommerce :")
        self.domain_edit = QLineEdit("https://www.planetebob.fr")
        layout.addWidget(self.domain_label)
        layout.addWidget(self.domain_edit)

        self.date_label = QLabel("Date (YYYY/MM) :")
        self.date_edit = QLineEdit("2025/07")
        layout.addWidget(self.date_label)
        layout.addWidget(self.date_edit)

        self.folder_btn = QPushButton("Choisir le dossier d'images")
        self.folder_btn.clicked.connect(self.choose_folder)
        layout.addWidget(self.folder_btn)

        actions = QHBoxLayout()
        self.start_btn = QPushButton("Comparer")
        self.start_btn.clicked.connect(self.start_comparison)
        actions.addWidget(self.start_btn)
        actions.addStretch()
        layout.addLayout(actions)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Variante",
            "Lien Woo",
            "Lien Concurrent",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        self.folder_path: Path | None = None
        self.worker: VariantWorker | None = None

    # ------------------------------------------------------------------
    def choose_folder(self) -> None:
        folder = QFileDialog.getExistingDirectory(self, "Sélectionner un dossier")
        if folder:
            self.folder_path = Path(folder)
            self.folder_btn.setText(f"Dossier : {self.folder_path.name}")

    def valid_date(self, text: str) -> bool:
        return bool(re.fullmatch(r"\d{4}/\d{2}", text))

    def generate_woo_links(self) -> list[str]:
        if not self.folder_path:
            return []

        date_path = self.date_edit.text().strip()
        if not self.valid_date(date_path):
            return []

        base_url = self.domain_edit.text().strip().rstrip("/")
        links: list[str] = []
        for file in sorted(self.folder_path.iterdir()):
            if file.suffix.lower() in self.ALLOWED_EXTENSIONS:
                links.append(
                    f"{base_url}/wp-content/uploads/{date_path}/{file.name}"
                )
        return links

    @Slot()
    def start_comparison(self) -> None:
        url = self.url_edit.text().strip()
        if not url or not self.folder_path:
            return

        self.start_btn.setEnabled(False)
        self.worker = VariantWorker(url)
        self.worker.finished.connect(self.comparison_finished)
        self.worker.start()

    @Slot(dict)
    def comparison_finished(self, variants: dict[str, str]) -> None:
        woo_links = self.generate_woo_links()
        self.table.setRowCount(0)
        for idx, (name, comp_link) in enumerate(variants.items()):
            row = self.table.rowCount()
            self.table.insertRow(row)
            woo_link = woo_links[idx] if idx < len(woo_links) else ""
            self.table.setItem(row, 0, QTableWidgetItem(name))
            self.table.setItem(row, 1, QTableWidgetItem(woo_link))
            self.table.setItem(row, 2, QTableWidgetItem(comp_link))
        self.start_btn.setEnabled(True)

===== MOTEUR/scraping/widgets/variant_widget.py =====
from __future__ import annotations

import logging
from typing import Optional

from PySide6.QtCore import QThread, Signal, Slot
from PySide6.QtWidgets import (
    QHBoxLayout,
    QLineEdit,
    QPushButton,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from ..scraping_variantes import (
    VARIANT_DEFAULT_SELECTOR,
    extract_variants_with_images,
)


class VariantWorker(QThread):
    """Thread running the variant extraction."""

    finished = Signal(str, dict)

    def __init__(self, url: str, selector: str) -> None:
        super().__init__()
        self.url = url
        self.selector = selector

    def run(self) -> None:  # noqa: D401 - QThread API
        try:
            title, variants = extract_variants_with_images(self.url)
        except Exception as exc:  # pragma: no cover - network/driver issues
            logging.getLogger(__name__).error("%s", exc)
            self.finished.emit("", {})
            return
        self.finished.emit(title, variants)


class ScrapingVariantsWidget(QWidget):
    """Simple GUI to scrape product variants from a URL."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("Lien du produit")
        layout.addWidget(self.url_edit)

        self.selector_edit = QLineEdit(VARIANT_DEFAULT_SELECTOR)
        self.selector_edit.setPlaceholderText("Sélecteur CSS des variantes")
        layout.addWidget(self.selector_edit)

        start_row = QHBoxLayout()
        start_row.addStretch()
        self.start_btn = QPushButton("Lancer")
        self.start_btn.clicked.connect(self.start_scraping)
        start_row.addWidget(self.start_btn)
        start_row.addStretch()
        layout.addLayout(start_row)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        self.worker: VariantWorker | None = None

    # ------------------------------------------------------------------
    @Slot()
    def start_scraping(self) -> None:
        url = self.url_edit.text().strip()
        if not url:
            self.console.append("⚠️ URL manquante")
            return
        selector = self.selector_edit.text().strip() or VARIANT_DEFAULT_SELECTOR
        self.console.clear()
        self.start_btn.setEnabled(False)

        self.worker = VariantWorker(url, selector)
        self.worker.finished.connect(self.scraping_finished)
        self.worker.start()

    @Slot(str, dict)
    def scraping_finished(self, title: str, variants: dict[str, str]) -> None:
        if title:
            self.console.append(f"Produit: {title}")
            for name, link in variants.items():
                self.console.append(f"- {name} : {link}")
        self.start_btn.setEnabled(True)

===== MOTEUR/scraping/widgets/woo_url_widget.py =====
from __future__ import annotations

import re
from pathlib import Path
from typing import Optional

import requests

from PySide6.QtWidgets import (
    QApplication,
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)
from PySide6.QtGui import QClipboard


class WooImageURLWidget(QWidget):
    """Generate WooCommerce URLs for images in a folder."""

    ALLOWED_EXTENSIONS = {".webp", ".jpg", ".jpeg", ".png"}

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)

        self.domain_label = QLabel("Domaine WooCommerce :")
        self.domain_edit = QLineEdit("https://www.planetebob.fr")
        layout.addWidget(self.domain_label)
        layout.addWidget(self.domain_edit)

        self.date_label = QLabel("Date (YYYY/MM) :")
        self.date_edit = QLineEdit("2025/07")
        layout.addWidget(self.date_label)
        layout.addWidget(self.date_edit)

        self.folder_btn = QPushButton("Choisir le dossier d'images")
        self.folder_btn.clicked.connect(self.choose_folder)
        layout.addWidget(self.folder_btn)

        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["URL", "Statut"])
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        actions = QHBoxLayout()
        self.generate_btn = QPushButton("G\u00e9n\u00e9rer")
        self.generate_btn.clicked.connect(self.generate_links)
        actions.addWidget(self.generate_btn)

        self.copy_btn = QPushButton("Copier")
        self.copy_btn.clicked.connect(self.copy_links)
        actions.addWidget(self.copy_btn)

        self.clear_btn = QPushButton("Effacer")
        self.clear_btn.clicked.connect(self.clear_table)
        actions.addWidget(self.clear_btn)

        self.export_btn = QPushButton("Exporter en .txt")
        self.export_btn.clicked.connect(self.export_links)
        actions.addWidget(self.export_btn)

        self.check_btn = QPushButton("Vérifier")
        self.check_btn.clicked.connect(self.verify_links)
        actions.addWidget(self.check_btn)

        layout.addLayout(actions)

        self.folder_path: Path | None = None

    # ------------------------------------------------------------------
    def choose_folder(self) -> None:
        """Prompt the user to select a folder containing images."""
        folder = QFileDialog.getExistingDirectory(self, "S\u00e9lectionner un dossier")
        if folder:
            self.folder_path = Path(folder)
            self.folder_btn.setText(f"Dossier : {self.folder_path.name}")

    def valid_date(self, text: str) -> bool:
        """Return True if *text* matches YYYY/MM."""
        return bool(re.fullmatch(r"\d{4}/\d{2}", text))

    def generate_links(self) -> None:
        """Generate URLs for images in the selected folder."""
        if not self.folder_path:
            QMessageBox.warning(self, "Erreur", "Veuillez choisir un dossier.")
            return

        date_path = self.date_edit.text().strip()
        if not self.valid_date(date_path):
            QMessageBox.warning(self, "Erreur", "Date invalide (YYYY/MM)")
            return

        base_url = self.domain_edit.text().strip().rstrip("/")
        links: list[str] = []
        for file in self.folder_path.iterdir():
            if file.suffix.lower() in self.ALLOWED_EXTENSIONS:
                url = f"{base_url}/wp-content/uploads/{date_path}/{file.name}"
                links.append(url)

        self.table.setRowCount(0)
        if links:
            for url in links:
                row = self.table.rowCount()
                self.table.insertRow(row)
                self.table.setItem(row, 0, QTableWidgetItem(url))
                self.table.setItem(row, 1, QTableWidgetItem(""))
        else:
            QMessageBox.information(
                self,
                "Information",
                "Aucune image valide trouv\u00e9e dans le dossier.",
            )

    def clear_table(self) -> None:
        """Remove all rows from the table."""
        self.table.setRowCount(0)

    def copy_links(self) -> None:
        """Copy generated links to the clipboard."""
        clipboard: QClipboard = QApplication.clipboard()
        links = []
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 0)
            if item:
                links.append(item.text())
        clipboard.setText("\n".join(links))
        QMessageBox.information(self, "Copi\u00e9", "Liens copi\u00e9s dans le presse-papiers.")

    def export_links(self) -> None:
        """Export generated links to a text file."""
        if self.table.rowCount() == 0:
            QMessageBox.warning(self, "Erreur", "Aucun lien \u00e0 exporter.")
            return
        path, _ = QFileDialog.getSaveFileName(
            self,
            "Enregistrer sous",
            "liens_images.txt",
            "Fichier texte (*.txt)",
        )
        if path:
            links = []
            for row in range(self.table.rowCount()):
                item = self.table.item(row, 0)
                if item:
                    links.append(item.text())
            Path(path).write_text("\n".join(links), encoding="utf-8")
            QMessageBox.information(self, "Export\u00e9", "Liens enregistr\u00e9s avec succ\u00e8s.")

    def verify_links(self) -> None:
        """Check each URL and warn about invalid ones."""
        if self.table.rowCount() == 0:
            QMessageBox.information(self, "V\u00e9rification", "Aucun lien \u00e0 v\u00e9rifier.")
            return

        invalid: list[str] = []
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 0)
            if not item:
                continue
            url = item.text().strip()
            if not url:
                continue
            try:
                resp = requests.head(url, allow_redirects=True, timeout=5)
                ok = resp.status_code == 200
            except Exception:  # pragma: no cover - network issues
                ok = False

            status_item = QTableWidgetItem("\u2705" if ok else "\u274c")
            self.table.setItem(row, 1, status_item)
            if not ok:
                invalid.append(url)

        if invalid:
            QMessageBox.warning(
                self,
                "Liens invalides",
                f"{len(invalid)} lien(s) invalide(s) trouv\u00e9(s).",
            )
        else:
            QMessageBox.information(self, "V\u00e9rification", "Tous les liens sont valides.")


