Code listing for compta module

===== MOTEUR/compta/__init__.py =====


===== MOTEUR/compta/accounting/__init__.py =====


===== MOTEUR/compta/accounting/db.py =====

from __future__ import annotations

from pathlib import Path
from typing import List

from ..db import connect
from ..models import EntryLine

SQL_CREATE_SEQUENCES = """
CREATE TABLE IF NOT EXISTS sequences (
    journal TEXT NOT NULL,
    fiscal_year INTEGER NOT NULL,
    next_number INTEGER NOT NULL,
    PRIMARY KEY (journal, fiscal_year)
)
"""

SQL_CREATE_ACCOUNTS = """
CREATE TABLE IF NOT EXISTS accounts (
    code TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    parent_code TEXT REFERENCES accounts(code)
)"""

SQL_CREATE_ENTRIES = """
CREATE TABLE IF NOT EXISTS entries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    journal TEXT NOT NULL,
    ref TEXT,
    date TEXT NOT NULL,
    memo TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_LINES = """
CREATE TABLE IF NOT EXISTS entry_lines (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE,
    account TEXT NOT NULL,
    debit REAL NOT NULL DEFAULT 0 CHECK(debit>=0),
    credit REAL NOT NULL DEFAULT 0 CHECK(credit>=0),
    description TEXT,
    letter_code TEXT
)"""

SQL_INSERT_ENTRY = (
    "INSERT INTO entries (journal, ref, date, memo) VALUES (?,?,?,?)"
)

SQL_INSERT_LINE = (
    "INSERT INTO entry_lines (entry_id, account, debit, credit, description)"
    " VALUES (?,?,?,?,?)"
)

SQL_IDX_ENTRIES_DATE = (
    "CREATE INDEX IF NOT EXISTS idx_entries_date ON entries(date)"
)

SQL_FETCH_LINES = (
    "SELECT account, debit, credit FROM entry_lines WHERE entry_id=?"
)


def _assert_balanced(conn, entry_id: int) -> None:
    cur = conn.execute(SQL_FETCH_LINES, (entry_id,))
    debit = credit = 0.0
    for _, d, c in cur.fetchall():
        debit += d
        credit += c
    if round(debit - credit, 2) != 0.0:
        raise ValueError("Entry not balanced")


def next_sequence(conn, journal: str, fiscal_year: int) -> str:
    cur = conn.execute(
        "SELECT next_number FROM sequences WHERE journal=? AND fiscal_year=?",
        (journal, fiscal_year),
    )
    row = cur.fetchone()
    if row is None:
        next_num = 1
        conn.execute(
            (
                "INSERT INTO sequences (journal, fiscal_year, next_number) "
                "VALUES (?,?,?)"
            ),
            (journal, fiscal_year, 2),
        )
    else:
        next_num = row[0]
        conn.execute(
            (
                "UPDATE sequences SET next_number=? WHERE journal=? "
                "AND fiscal_year=?"
            ),
            (next_num + 1, journal, fiscal_year),
        )
    return f"{journal}{str(fiscal_year)[-2:]}{next_num:05d}"


def init_db(db_path: Path | str) -> None:
    """Create tables for accounting entries."""
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_ACCOUNTS)
        conn.execute(SQL_CREATE_ENTRIES)
        conn.execute(SQL_CREATE_LINES)
        conn.execute(SQL_CREATE_SEQUENCES)
        conn.execute(SQL_IDX_ENTRIES_DATE)
        conn.commit()


def create_entry(
    db_path: Path | str,
    journal: str,
    date: str,
    ref: str,
    memo: str,
    lines: List[EntryLine],
) -> int:
    """Create an accounting entry and its lines."""
    with connect(db_path) as conn:
        entry_id = _create_entry(conn, journal, date, ref, memo, lines)
        conn.commit()
        return entry_id


def _create_entry(
    conn,
    journal: str,
    date: str,
    ref: str,
    memo: str,
    lines: List[EntryLine],
) -> int:
    cur = conn.execute(SQL_INSERT_ENTRY, (journal, ref, date, memo))
    entry_id = cur.lastrowid
    for line in lines:
        conn.execute(
            SQL_INSERT_LINE,
            (
                entry_id,
                line.account,
                line.debit,
                line.credit,
                line.description,
            ),
        )
    _assert_balanced(conn, entry_id)
    return entry_id


def entry_balanced(db_path: Path | str, entry_id: int) -> bool:
    """Return True if the entry debits equal credits."""
    with connect(db_path) as conn:
        cur = conn.execute(SQL_FETCH_LINES, (entry_id,))
        debit = 0.0
        credit = 0.0
        for row in cur.fetchall():
            debit += row[1]
            credit += row[2]
        return round(debit - credit, 2) == 0.0


def close_fiscal_year(db_path: Path | str, year: int) -> None:
    """Placeholder for fiscal year closing logic."""
    # For demo purposes we only mark the year as closed in a table.
    with connect(db_path) as conn:
        conn.execute(
            (
                "CREATE TABLE IF NOT EXISTS closed_years "
                "(year INTEGER PRIMARY KEY)"
            )
        )
        conn.execute(
            "INSERT OR IGNORE INTO closed_years(year) VALUES (?)",
            (year,),
        )
        conn.commit()


def export_fec(db_path: Path | str, year: int, dest: Path) -> None:
    """Export entries for *year* to a simple FEC-like CSV file."""
    header = [
        "JournalCode",
        "EcritureNum",
        "EcritureDate",
        "CompteNum",
        "Libelle",
        "Debit",
        "Credit",
    ]
    with connect(db_path) as conn, dest.open("w", encoding="utf-8") as fh:
        fh.write(";".join(header) + "\n")
        cur = conn.execute(
            (
                "SELECT id, journal, ref, date FROM entries "
                "WHERE substr(date,1,4)=?"
            ),
            (str(year),),
        )
        for entry_id, journal, ref, date in cur.fetchall():
            lcur = conn.execute(
                (
                    "SELECT account, debit, credit, description FROM "
                    "entry_lines WHERE entry_id=?"
                ),
                (entry_id,),
            )
            line_num = 1
            for account, debit, credit, desc in lcur.fetchall():
                fh.write(
                    f"{journal};{entry_id}-{line_num};{date};{account};"
                    f"{desc or ref};{debit:.2f};{credit:.2f}\n"
                )
                line_num += 1


def apply_letter(db_path: Path | str, code: str, entry_ids: list[int]) -> None:
    """Assign *code* to lines belonging to *entry_ids*."""
    if not entry_ids:
        return
    qmarks = ",".join("?" for _ in entry_ids)
    with connect(db_path) as conn:
        conn.execute(
            (
                "UPDATE entry_lines SET letter_code=? WHERE entry_id "
                f"IN ({qmarks})"
            ),
            [code, *entry_ids],
        )
        conn.commit()

===== MOTEUR/compta/achats/__init__.py =====


===== MOTEUR/compta/achats/db.py =====

from __future__ import annotations

from pathlib import Path
from typing import List

from ..db import connect
from ..models import EntryLine, Purchase, PurchaseFilter, VatLine
from ..accounting.db import (
    _create_entry,
    init_db as init_accounting,
    next_sequence,
)


def _ensure_account(conn, code: str) -> None:
    conn.execute(
        "INSERT OR IGNORE INTO accounts(code, name) VALUES (?, ?)",
        (code, ""),
    )


SQL_CREATE_SUPPLIERS = """
CREATE TABLE IF NOT EXISTS suppliers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    vat_number TEXT,
    address TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_PURCHASES = """
CREATE TABLE IF NOT EXISTS purchases (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL,
    invoice_number TEXT NOT NULL,
    supplier_id INTEGER NOT NULL REFERENCES suppliers(id),
    label TEXT NOT NULL,
    ht_amount REAL NOT NULL CHECK(ht_amount >= 0),
    vat_amount REAL NOT NULL CHECK(vat_amount >= 0),
    vat_rate REAL NOT NULL CHECK(vat_rate IN (0,2.1,5.5,10,20)),
    account_code TEXT NOT NULL REFERENCES accounts(code),
    due_date TEXT NOT NULL,
    payment_status TEXT NOT NULL CHECK(
        payment_status IN ('A_PAYER','PAYE','PARTIEL')
    ),
    payment_date TEXT,
    payment_method TEXT,
    is_advance INTEGER DEFAULT 0 CHECK(is_advance IN (0,1)),
    is_invoice_received INTEGER DEFAULT 1 CHECK(is_invoice_received IN (0,1)),
    attachment_path TEXT,
    created_by TEXT,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
)"""

SQL_CREATE_INDEXES = [
    (
        "CREATE UNIQUE INDEX IF NOT EXISTS unq_supplier_invoice "
        "ON purchases(supplier_id, invoice_number)"
    ),
    "CREATE INDEX IF NOT EXISTS idx_purchases_date ON purchases(date)",
    (
        "CREATE INDEX IF NOT EXISTS idx_purchases_supplier "
        "ON purchases(supplier_id)"
    ),
]

SQL_TRIGGER_INSERT = """
CREATE TRIGGER IF NOT EXISTS trg_purchase_vat
BEFORE INSERT ON purchases
FOR EACH ROW
BEGIN
  SELECT CASE
    WHEN ROUND(NEW.ht_amount * NEW.vat_rate / 100, 2) <> NEW.vat_amount
    THEN RAISE(FAIL, 'VAT amount inconsistent with HT × rate')
  END;
END;
"""

SQL_TRIGGER_UPDATE = """
CREATE TRIGGER IF NOT EXISTS trg_purchase_vat_up
BEFORE UPDATE ON purchases
FOR EACH ROW
BEGIN
  SELECT CASE
    WHEN ROUND(NEW.ht_amount * NEW.vat_rate / 100, 2) <> NEW.vat_amount
    THEN RAISE(FAIL, 'VAT amount inconsistent with HT × rate')
  END;
END;
"""

SQL_INSERT_PURCHASE = """
    INSERT INTO purchases (
        date, invoice_number, supplier_id, label, ht_amount, vat_amount,
        vat_rate, account_code, due_date, payment_status, payment_date,
        payment_method, is_advance, is_invoice_received, attachment_path,
        created_by
    ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """

SQL_UPDATE_PURCHASE = """
    UPDATE purchases SET
        date=?, invoice_number=?, supplier_id=?, label=?, ht_amount=?,
        vat_amount=?, vat_rate=?, account_code=?, due_date=?,
        payment_status=?, payment_date=?, payment_method=?, is_advance=?,
        is_invoice_received=?, attachment_path=?, updated_at=CURRENT_TIMESTAMP
    WHERE id=?
    """

SQL_VAT_SUMMARY = (
    "SELECT vat_rate, SUM(ht_amount) as base, SUM(vat_amount) as vat"
    " FROM purchases WHERE date BETWEEN ? AND ? GROUP BY vat_rate"
)


def init_db(db_path: Path | str) -> None:
    """Create purchase related tables."""
    init_accounting(db_path)
    with connect(db_path) as conn:
        conn.execute(SQL_CREATE_SUPPLIERS)
        conn.execute(SQL_CREATE_PURCHASES)
        for sql in SQL_CREATE_INDEXES:
            conn.execute(sql)
        conn.execute(SQL_TRIGGER_INSERT)
        conn.execute(SQL_TRIGGER_UPDATE)
        conn.commit()


def add_purchase(db_path: Path | str, pur: Purchase) -> int:
    """Insert *pur* and generate accounting entry."""
    vat = round(pur.ht_amount * pur.vat_rate / 100, 2)
    pur.vat_amount = vat
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            if pur.invoice_number == "AUTO":
                pur.invoice_number = next_sequence(
                    conn, "AC", int(pur.date[:4])
                )
            _ensure_account(conn, pur.account_code)
            cur = conn.execute(
                SQL_INSERT_PURCHASE,
                (
                    pur.date,
                    pur.invoice_number,
                    pur.supplier_id,
                    pur.label,
                    pur.ht_amount,
                    pur.vat_amount,
                    pur.vat_rate,
                    pur.account_code,
                    pur.due_date,
                    pur.payment_status,
                    pur.payment_date,
                    pur.payment_method,
                    pur.is_advance,
                    pur.is_invoice_received,
                    pur.attachment_path,
                    pur.created_by,
                ),
            )
            pur.id = cur.lastrowid
            credit_account = (
                "4091"
                if pur.is_advance
                else ("408" if not pur.is_invoice_received else "401")
            )
            vat_account = (
                "44562" if pur.account_code.startswith("2") else "44566"
            )
            lines = [
                EntryLine(
                    account=pur.account_code,
                    debit=pur.ht_amount,
                    credit=0.0,
                ),
                EntryLine(
                    account=vat_account, debit=pur.vat_amount, credit=0.0
                ),
                EntryLine(
                    account=credit_account,
                    debit=0.0,
                    credit=pur.ht_amount + pur.vat_amount,
                ),
            ]
            _create_entry(
                conn,
                "ACH",
                pur.date,
                pur.invoice_number,
                pur.label,
                lines,
            )
            conn.commit()
            return pur.id
        except Exception:
            conn.rollback()
            raise


def update_purchase(db_path: Path | str, pur: Purchase) -> None:
    """Update *pur* and recreate its accounting entry."""
    if pur.id is None:
        raise ValueError("Purchase id required")
    vat = round(pur.ht_amount * pur.vat_rate / 100, 2)
    pur.vat_amount = vat
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            if pur.invoice_number == "AUTO":
                pur.invoice_number = next_sequence(
                    conn, "AC", int(pur.date[:4])
                )
            _ensure_account(conn, pur.account_code)
            conn.execute(
                SQL_UPDATE_PURCHASE,
                (
                    pur.date,
                    pur.invoice_number,
                    pur.supplier_id,
                    pur.label,
                    pur.ht_amount,
                    pur.vat_amount,
                    pur.vat_rate,
                    pur.account_code,
                    pur.due_date,
                    pur.payment_status,
                    pur.payment_date,
                    pur.payment_method,
                    pur.is_advance,
                    pur.is_invoice_received,
                    pur.attachment_path,
                    pur.id,
                ),
            )
            # delete previous entry
            cur = conn.execute(
                "SELECT id FROM entries WHERE journal='ACH' AND ref=?",
                (pur.invoice_number,),
            )
            row = cur.fetchone()
            if row:
                entry_id = row[0]
                conn.execute(
                    "DELETE FROM entry_lines WHERE entry_id=?",
                    (entry_id,),
                )
                conn.execute(
                    "DELETE FROM entries WHERE id=?",
                    (entry_id,),
                )
            credit_account = (
                "4091"
                if pur.is_advance
                else ("408" if not pur.is_invoice_received else "401")
            )
            vat_account = (
                "44562" if pur.account_code.startswith("2") else "44566"
            )
            lines = [
                EntryLine(
                    account=pur.account_code,
                    debit=pur.ht_amount,
                    credit=0.0,
                ),
                EntryLine(
                    account=vat_account, debit=pur.vat_amount, credit=0.0
                ),
                EntryLine(
                    account=credit_account,
                    debit=0.0,
                    credit=pur.ht_amount + pur.vat_amount,
                ),
            ]
            _create_entry(
                conn,
                "ACH",
                pur.date,
                pur.invoice_number,
                pur.label,
                lines,
            )
            conn.commit()
        except Exception:
            conn.rollback()
            raise


def pay_purchase(
    db_path: Path | str,
    purchase_id: int,
    payment_date: str,
    method: str,
    amount: float,
) -> None:
    """Register a payment entry for the purchase."""
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            cur = conn.execute(
                (
                    "SELECT ht_amount, vat_amount, invoice_number, "
                    "payment_status, is_advance, is_invoice_received "
                    "FROM purchases WHERE id=?"
                ),
                (purchase_id,),
            )
            row = cur.fetchone()
            if not row:
                raise ValueError("Invalid purchase id")
            total = row[0] + row[1]
            paid = conn.execute(
                (
                    "SELECT COALESCE(SUM(credit),0) FROM entry_lines "
                    "WHERE account='512' AND entry_id IN "
                    "(SELECT id FROM entries WHERE journal='BQ' AND ref=?)"
                ),
                (row[2],),
            ).fetchone()[0]
            status = "PAYE" if amount + paid >= total else "PARTIEL"
            conn.execute(
                (
                    "UPDATE purchases SET payment_status=?, payment_date=?, "
                    "payment_method=? WHERE id=?"
                ),
                (
                    status,
                    payment_date,
                    method,
                    purchase_id,
                ),
            )
            credit_account = (
                "4091" if row[4] else ("408" if not row[5] else "401")
            )
            lines = [
                EntryLine(account=credit_account, debit=amount, credit=0.0),
                EntryLine(account="512", debit=0.0, credit=amount),
            ]
            _create_entry(
                conn,
                "BQ",
                payment_date,
                row[2],
                f"Paiement facture {row[2]}",
                lines,
            )
            conn.commit()
        except Exception:
            conn.rollback()
            raise


def delete_purchase(db_path: Path | str, purchase_id: int) -> None:
    """Delete the purchase and its accounting entry."""
    with connect(db_path) as conn:
        conn.execute("BEGIN")
        try:
            cur = conn.execute(
                "SELECT invoice_number FROM purchases WHERE id=?",
                (purchase_id,),
            )
            row = cur.fetchone()
            if not row:
                raise ValueError("Invalid purchase id")
            invoice = row[0]

            conn.execute(
                "DELETE FROM purchases WHERE id=?",
                (purchase_id,),
            )

            cur = conn.execute(
                "SELECT id FROM entries WHERE journal='ACH' AND ref=?",
                (invoice,),
            )
            row = cur.fetchone()
            if row:
                entry_id = row[0]
                conn.execute(
                    "DELETE FROM entry_lines WHERE entry_id=?",
                    (entry_id,),
                )
                conn.execute(
                    "DELETE FROM entries WHERE id=?",
                    (entry_id,),
                )
            conn.commit()
        except Exception:
            conn.rollback()
            raise


def fetch_purchases(
    db_path: Path | str,
    flt: PurchaseFilter,
) -> List[Purchase]:
    """Return purchases filtered according to *flt*."""
    query = "SELECT * FROM purchases WHERE 1=1"
    params: List = []
    if flt.start:
        query += " AND date >= ?"
        params.append(flt.start)
    if flt.end:
        query += " AND date <= ?"
        params.append(flt.end)
    if flt.supplier_id:
        query += " AND supplier_id = ?"
        params.append(flt.supplier_id)
    if flt.status:
        query += " AND payment_status = ?"
        params.append(flt.status)
    query += " ORDER BY date"
    with connect(db_path) as conn:
        cur = conn.execute(query, params)
        rows = cur.fetchall()
        return [Purchase(**dict(row)) for row in rows]


def fetch_all_purchases(db_path: Path | str):
    """Return purchases as (id, date, label, ttc, due_date, status)."""
    with connect(db_path) as conn:
        cur = conn.execute(
            (
                "SELECT id, date, label, ht_amount + vat_amount as ttc, "
                "due_date, payment_status FROM purchases ORDER BY date"
            )
        )
        return [
            (
                r["id"],
                r["date"],
                r["label"],
                r["ttc"],
                r["due_date"],
                r["payment_status"],
            )
            for r in cur.fetchall()
        ]


def get_vat_summary(
    db_path: Path | str,
    start: str,
    end: str,
) -> List[VatLine]:
    """Return VAT summary per rate between *start* and *end*."""
    with connect(db_path) as conn:
        cur = conn.execute(SQL_VAT_SUMMARY, (start, end))
        return [
            VatLine(rate=r[0], base=r[1], vat=r[2]) for r in cur.fetchall()
        ]

===== MOTEUR/compta/achats/widget.py =====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, QDate
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QComboBox,
    QFileDialog,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_purchase,
    update_purchase,
    delete_purchase,
    fetch_all_purchases,
)
from ..models import Purchase
from ..accounting.db import next_sequence
from ..db import connect

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class AchatWidget(QWidget):
    """Widget pour la gestion des achats."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form_layout.addWidget(self.date_edit)

        form_layout.addWidget(QLabel("Fournisseur:"))
        self.supplier_combo = QComboBox()
        self.load_suppliers()
        form_layout.addWidget(self.supplier_combo)

        form_layout.addWidget(QLabel("Facture:"))
        self.invoice_edit = QLineEdit()
        self.invoice_edit.setText(self.get_next_inv())
        form_layout.addWidget(self.invoice_edit)

        form_layout.addWidget(QLabel("Libell\u00e9:"))
        self.label_edit = QLineEdit()
        form_layout.addWidget(self.label_edit)

        form_layout.addWidget(QLabel("Montant HT:"))
        self.amount_spin = QDoubleSpinBox()
        self.amount_spin.setDecimals(2)
        self.amount_spin.setMaximum(1e9)
        form_layout.addWidget(self.amount_spin)

        form_layout.addWidget(QLabel("Taux TVA:"))
        self.vat_combo = QComboBox()
        for r in [0, 2.1, 5.5, 10, 20]:
            self.vat_combo.addItem(str(r))
        form_layout.addWidget(self.vat_combo)

        form_layout.addWidget(QLabel("Compte 6xx:"))
        self.account_combo = QComboBox()
        self.load_expense_accounts()
        form_layout.addWidget(self.account_combo)

        form_layout.addWidget(QLabel("\u00c9ch\u00e9ance:"))
        self.due_edit = QDateEdit(QDate.currentDate().addDays(30))
        self.due_edit.setCalendarPopup(True)
        form_layout.addWidget(self.due_edit)

        self.attach_btn = QPushButton("Pi\u00e8ce")
        self.attach_btn.clicked.connect(self.choose_file)
        form_layout.addWidget(self.attach_btn)

        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_purchase)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_purchase)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_purchase)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(
            [
                "Date",
                "Libell\u00e9",
                "Montant",
            ]
        )
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_purchases()
        self.attachment_path = None

    def get_selected_id(self) -> int | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.data(Qt.UserRole)

    def load_suppliers(self) -> None:
        self.supplier_combo.clear()
        with connect(db_path) as conn:
            for sid, name in conn.execute("SELECT id, name FROM suppliers"):
                self.supplier_combo.addItem(name, sid)

    def load_expense_accounts(self) -> None:
        self.account_combo.clear()
        with connect(db_path) as conn:
            cur = conn.execute(
                "SELECT code, name FROM accounts WHERE code LIKE '60%'"
            )
            for code, name in cur.fetchall():
                self.account_combo.addItem(f"{code} {name}", code)

    def get_next_inv(self) -> str:
        with connect(db_path) as conn:
            return next_sequence(conn, "AC", QDate.currentDate().year())

    def choose_file(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Pièce")
        if path:
            self.attachment_path = path

    @Slot()
    def add_purchase(self) -> None:
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Achat",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        pur = Purchase(
            id=None,
            date=date,
            invoice_number=self.invoice_edit.text() or "AUTO",
            supplier_id=self.supplier_combo.currentData(),
            label=label,
            ht_amount=amount,
            vat_amount=0.0,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=self.due_edit.date().toString("yyyy-MM-dd"),
            payment_status="A_PAYER",
            attachment_path=getattr(self, "attachment_path", None),
        )
        add_purchase(db_path, pur)
        self.load_purchases()

    @Slot()
    def edit_purchase(self) -> None:
        purchase_id = self.get_selected_id()
        if purchase_id is None:
            QMessageBox.warning(
                self,
                "Achat",
                "S\u00e9lectionnez un achat",
            )
            return
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Achat",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        pur = Purchase(
            id=purchase_id,
            date=date,
            invoice_number=self.invoice_edit.text() or "AUTO",
            supplier_id=self.supplier_combo.currentData(),
            label=label,
            ht_amount=amount,
            vat_amount=0.0,
            vat_rate=float(self.vat_combo.currentText()),
            account_code=self.account_combo.currentData(),
            due_date=self.due_edit.date().toString("yyyy-MM-dd"),
            payment_status="A_PAYER",
            attachment_path=getattr(self, "attachment_path", None),
        )
        update_purchase(db_path, pur)
        self.load_purchases()

    @Slot()
    def remove_purchase(self) -> None:
        purchase_id = self.get_selected_id()
        if purchase_id is None:
            QMessageBox.warning(self, "Achat", "S\u00e9lectionnez un achat")
            return
        delete_purchase(db_path, purchase_id)
        self.load_purchases()

    def load_purchases(self) -> None:
        self.table.setRowCount(0)
        today = QDate.currentDate()
        for (
            purchase_id,
            date,
            label,
            amount,
            due,
            status,
        ) in fetch_all_purchases(db_path):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item_date = QTableWidgetItem(date)
            item_date.setData(Qt.UserRole, purchase_id)
            self.table.setItem(row, 0, item_date)
            self.table.setItem(row, 1, QTableWidgetItem(label))
            amt_item = QTableWidgetItem(f"{amount:.2f}")
            if (
                QDate.fromString(due, "yyyy-MM-dd") < today
                and status == "A_PAYER"
            ):
                for col in range(3):
                    self.table.item(row, col).setForeground(Qt.red)
            self.table.setItem(row, 2, amt_item)

    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_date = self.table.item(row, 0)
        item_label = self.table.item(row, 1)
        item_amount = self.table.item(row, 2)
        if item_date and item_label and item_amount:
            self.date_edit.setDate(
                QDate.fromString(item_date.text(), "yyyy-MM-dd")
            )
            self.label_edit.setText(item_label.text())
            self.amount_spin.setValue(float(item_amount.text()))
            # restore other fields from DB
            pid = item_date.data(Qt.UserRole)
            with connect(db_path) as conn:
                cur = conn.execute(
                    "SELECT supplier_id, invoice_number, vat_rate, "
                    "account_code, due_date, attachment_path "
                    "FROM purchases WHERE id=?",
                    (pid,),
                )
                r = cur.fetchone()
                if r:
                    idx = self.supplier_combo.findData(r[0])
                    if idx >= 0:
                        self.supplier_combo.setCurrentIndex(idx)
                    self.invoice_edit.setText(r[1])
                    idx = self.vat_combo.findText(str(r[2]))
                    if idx >= 0:
                        self.vat_combo.setCurrentIndex(idx)
                    idx = self.account_combo.findData(r[3])
                    if idx >= 0:
                        self.account_combo.setCurrentIndex(idx)
                    self.due_edit.setDate(QDate.fromString(r[4], "yyyy-MM-dd"))
                    self.attachment_path = r[5]

===== MOTEUR/compta/dashboard/__init__.py =====


===== MOTEUR/compta/dashboard/widget.py =====

from __future__ import annotations

from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Optional
import json

from PySide6.QtCore import Slot, Signal
from PySide6.QtWidgets import (
    QLabel,
    QVBoxLayout,
    QWidget,
    QCheckBox,
    QHBoxLayout,
    QPushButton,
)

from ..achats.db import fetch_all_purchases, init_db

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database used in AchatWidget
DB_PATH = BASE_DIR / "compta.db"
CONFIG_PATH = Path(__file__).with_name("config.json")

DEFAULT_CONFIG = {
    "show_total_count": True,
    "show_total_amount": True,
    "show_avg_per_month": True,
    "show_chart": True,
}

try:
    import matplotlib

    matplotlib.use("QtAgg")  # Use Qt backend for PySide6
    from matplotlib.backends.backend_qtagg import (
        FigureCanvasQTAgg as FigureCanvas,
    )
    from matplotlib.figure import Figure

    MPL_AVAILABLE = True
except Exception:  # pragma: no cover - matplotlib is optional
    MPL_AVAILABLE = False


def load_dashboard_config() -> dict:
    """Return dashboard configuration from :data:`CONFIG_PATH`."""
    if CONFIG_PATH.exists():
        try:
            with CONFIG_PATH.open("r", encoding="utf-8") as fh:
                data = json.load(fh)
            return {**DEFAULT_CONFIG, **{k: bool(v) for k, v in data.items()}}
        except Exception:
            return DEFAULT_CONFIG.copy()
    CONFIG_PATH.write_text(
        json.dumps(DEFAULT_CONFIG, indent=2, ensure_ascii=False)
    )
    return DEFAULT_CONFIG.copy()


def save_dashboard_config(config: dict) -> None:
    """Write *config* to :data:`CONFIG_PATH`."""
    with CONFIG_PATH.open("w", encoding="utf-8") as fh:
        json.dump(config, fh, ensure_ascii=False, indent=2)


def build_summary_text(
    total: int,
    amount: float,
    avg: float,
    config: dict,
) -> str:
    """Return summary text based on *config*."""
    lines: list[str] = []
    if config.get("show_total_count", True):
        lines.append(f"Nombre d'achats : {total}")
    if config.get("show_total_amount", True):
        lines.append(f"Total : {amount:.2f} \u20ac")
    if config.get("show_avg_per_month", True):
        lines.append(f"Moyenne par mois : {avg:.2f} \u20ac")
    return "\n".join(lines)


class DashboardWidget(QWidget):
    """Widget displaying purchase statistics with an optional graph."""

    journal_requested = Signal()
    grand_livre_requested = Signal()
    scraping_summary_requested = Signal()

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(DB_PATH)

        self.config = load_dashboard_config()

        layout = QVBoxLayout(self)

        nav_layout = QHBoxLayout()
        journal_btn = QPushButton("Journal")
        journal_btn.clicked.connect(self.journal_requested.emit)
        nav_layout.addWidget(journal_btn)

        grand_btn = QPushButton("Grand Livre")
        grand_btn.clicked.connect(self.grand_livre_requested.emit)
        nav_layout.addWidget(grand_btn)

        scrap_btn = QPushButton("Dernier scraping")
        scrap_btn.clicked.connect(self.scraping_summary_requested.emit)
        nav_layout.addWidget(scrap_btn)
        layout.addLayout(nav_layout)

        self.summary_label = QLabel()
        layout.addWidget(self.summary_label)

        if MPL_AVAILABLE:
            self.figure = Figure(figsize=(5, 3))
            self.canvas = FigureCanvas(self.figure)
            layout.addWidget(self.canvas)
        else:  # pragma: no cover - depends on matplotlib being installed
            self.figure = None
            self.canvas = None
            layout.addWidget(
                QLabel("matplotlib requis pour l'affichage du graphique")
            )

        config_layout = QHBoxLayout()
        self.count_cb = QCheckBox("Nombre")
        self.amount_cb = QCheckBox("Total")
        self.avg_cb = QCheckBox("Moyenne/mois")
        self.chart_cb = QCheckBox("Graphique")
        for key, cb in [
            ("show_total_count", self.count_cb),
            ("show_total_amount", self.amount_cb),
            ("show_avg_per_month", self.avg_cb),
            ("show_chart", self.chart_cb),
        ]:
            cb.setChecked(self.config.get(key, True))
            cb.stateChanged.connect(self._config_changed)
            config_layout.addWidget(cb)
        layout.addLayout(config_layout)

        self.refresh()

    # ------------------------------------------------------------------
    @Slot()
    def _config_changed(self) -> None:
        """Persist config and refresh widgets when checkboxes change."""
        self.config = {
            "show_total_count": self.count_cb.isChecked(),
            "show_total_amount": self.amount_cb.isChecked(),
            "show_avg_per_month": self.avg_cb.isChecked(),
            "show_chart": self.chart_cb.isChecked(),
        }
        save_dashboard_config(self.config)
        self.refresh()

    # ------------------------------------------------------------------
    def _load_purchases(self) -> list[tuple[int, str, str, float]]:
        return fetch_all_purchases(DB_PATH)

    def _compute_metrics(self, rows: list[tuple[int, str, str, float]]):
        total_count = len(rows)
        total_amount = sum(r[3] for r in rows)

        by_month: dict[str, float] = defaultdict(float)
        for _pid, date_str, _label, amount in rows:
            try:
                dt = datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                continue
            key = dt.strftime("%Y-%m")
            by_month[key] += amount
        avg_per_month = total_amount / len(by_month) if by_month else 0.0
        return total_count, total_amount, avg_per_month, by_month

    def _update_summary(self, total: int, amount: float, avg: float) -> None:
        text = build_summary_text(total, amount, avg, self.config)
        self.summary_label.setText(text)
        self.summary_label.setVisible(bool(text))

    def _update_chart(self, by_month: dict[str, float]) -> None:
        if not MPL_AVAILABLE or not self.figure:
            return
        if not self.config.get("show_chart", True):
            if self.canvas:
                self.canvas.hide()
            return
        if self.canvas:
            self.canvas.show()
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        months = sorted(by_month)
        amounts = [by_month[m] for m in months]
        ax.bar(months, amounts, color="#539ecd")
        ax.set_xlabel("Mois")
        ax.set_ylabel("Montant")
        ax.set_title("Achats par mois")
        self.figure.autofmt_xdate(rotation=45)
        self.canvas.draw()

    # Public API --------------------------------------------------------
    @Slot()
    def refresh(self) -> None:
        """Reload purchases from the database and update widgets."""
        rows = self._load_purchases()
        total, amount, avg, by_month = self._compute_metrics(rows)
        self._update_summary(total, amount, avg)
        self._update_chart(by_month)

===== MOTEUR/compta/db.py =====

from __future__ import annotations

import sqlite3
from pathlib import Path

MEM_URI = "file:memdb1?mode=memory&cache=shared"


def connect(db_path: Path | str) -> sqlite3.Connection:
    """Return a SQLite connection with foreign keys enabled."""
    db_str = str(db_path)
    if db_str == ":memory:":
        conn = sqlite3.connect(MEM_URI, uri=True)
    else:
        conn = sqlite3.connect(db_str, uri=db_str.startswith("file:"))
    conn.execute("PRAGMA foreign_keys = ON")
    conn.row_factory = sqlite3.Row
    return conn

===== MOTEUR/compta/models.py =====

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional


@dataclass
class Supplier:
    """Supplier information."""

    id: Optional[int]
    name: str
    vat_number: Optional[str] = None
    address: Optional[str] = None


@dataclass
class Purchase:
    """Purchase record."""

    id: Optional[int]
    date: str
    invoice_number: str
    supplier_id: int
    label: str
    ht_amount: float
    vat_amount: float
    vat_rate: float
    account_code: str
    due_date: str
    payment_status: str
    payment_date: Optional[str] = None
    payment_method: Optional[str] = None
    is_advance: int = 0
    is_invoice_received: int = 1
    attachment_path: Optional[str] = None
    created_by: Optional[str] = None
    updated_at: Optional[str] = None


@dataclass
class EntryLine:
    """Accounting entry line."""

    account: str
    debit: float = 0.0
    credit: float = 0.0
    description: Optional[str] = None


@dataclass
class PurchaseFilter:
    """Filters for querying purchases."""

    start: Optional[str] = None
    end: Optional[str] = None
    supplier_id: Optional[int] = None
    status: Optional[str] = None


@dataclass
class VatLine:
    """VAT summary line."""

    rate: float
    base: float
    vat: float

===== MOTEUR/compta/ventes/__init__.py =====


===== MOTEUR/compta/ventes/db.py =====

from __future__ import annotations

import sqlite3
from pathlib import Path
from typing import List, Tuple


def init_db(db_path: Path) -> None:
    """Create the sales table if it does not already exist."""
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS sales (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                label TEXT NOT NULL,
                amount REAL NOT NULL
            )
            """
        )
        conn.commit()


def add_sale(db_path: Path, date: str, label: str, amount: float) -> int:
    """Add a sale row and return its new id."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.execute(
            "INSERT INTO sales (date, label, amount) VALUES (?, ?, ?)",
            (date, label, amount),
        )
        conn.commit()
        return cursor.lastrowid


def update_sale(
    db_path: Path, sale_id: int, date: str, label: str, amount: float
) -> None:
    """Update a sale row identified by *sale_id*."""
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            (
                "UPDATE sales SET date = ?, label = ?, amount = ? "
                "WHERE id = ?"
            ),
            (date, label, amount, sale_id),
        )
        conn.commit()


def delete_sale(db_path: Path, sale_id: int) -> None:
    """Delete the sale row identified by *sale_id*."""
    with sqlite3.connect(db_path) as conn:
        conn.execute("DELETE FROM sales WHERE id = ?", (sale_id,))
        conn.commit()


def fetch_all_sales(db_path: Path) -> List[Tuple[int, str, str, float]]:
    """Return all sale rows."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.execute(
            "SELECT id, date, label, amount FROM sales ORDER BY date"
        )
        return cursor.fetchall()

===== MOTEUR/compta/ventes/widget.py =====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from PySide6.QtCore import Qt, Slot, QDate
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QMessageBox,
)

from .db import (
    init_db,
    add_sale,
    update_sale,
    delete_sale,
    fetch_all_sales,
)

BASE_DIR = Path(__file__).resolve().parent.parent.parent
# Default path to the SQLite database
db_path = BASE_DIR / "compta.db"


class VenteWidget(QWidget):
    """Widget pour la gestion des ventes."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        init_db(db_path)

        layout = QVBoxLayout(self)

        form_layout = QHBoxLayout()
        form_layout.addWidget(QLabel("Date:"))
        self.date_edit = QDateEdit(QDate.currentDate())
        self.date_edit.setCalendarPopup(True)
        form_layout.addWidget(self.date_edit)

        form_layout.addWidget(QLabel("Libell\u00e9:"))
        self.label_edit = QLineEdit()
        form_layout.addWidget(self.label_edit)

        form_layout.addWidget(QLabel("Montant:"))
        self.amount_spin = QDoubleSpinBox()
        self.amount_spin.setDecimals(2)
        self.amount_spin.setMaximum(1e9)
        form_layout.addWidget(self.amount_spin)

        layout.addLayout(form_layout)

        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self.add_sale)
        btn_layout.addWidget(self.add_btn)
        self.mod_btn = QPushButton("Modifier")
        self.mod_btn.clicked.connect(self.edit_sale)
        btn_layout.addWidget(self.mod_btn)
        self.del_btn = QPushButton("Supprimer")
        self.del_btn.clicked.connect(self.remove_sale)
        btn_layout.addWidget(self.del_btn)
        layout.addLayout(btn_layout)

        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Date",
            "Libell\u00e9",
            "Montant",
        ])
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.table.cellClicked.connect(self.fill_fields_from_row)
        layout.addWidget(self.table)

        self.load_sales()

    def get_selected_id(self) -> int | None:
        row = self.table.currentRow()
        if row < 0:
            return None
        item = self.table.item(row, 0)
        if not item:
            return None
        return item.data(Qt.UserRole)

    @Slot()
    def add_sale(self) -> None:
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Vente",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        add_sale(db_path, date, label, amount)
        self.load_sales()

    @Slot()
    def edit_sale(self) -> None:
        sale_id = self.get_selected_id()
        if sale_id is None:
            QMessageBox.warning(
                self,
                "Vente",
                "S\u00e9lectionnez une vente",
            )
            return
        label = self.label_edit.text().strip()
        if not label:
            QMessageBox.warning(
                self,
                "Vente",
                "Veuillez saisir un libell\u00e9",
            )
            return
        date = self.date_edit.date().toString("yyyy-MM-dd")
        amount = self.amount_spin.value()
        update_sale(db_path, sale_id, date, label, amount)
        self.load_sales()

    @Slot()
    def remove_sale(self) -> None:
        sale_id = self.get_selected_id()
        if sale_id is None:
            QMessageBox.warning(self, "Vente", "S\u00e9lectionnez une vente")
            return
        delete_sale(db_path, sale_id)
        self.load_sales()

    def load_sales(self) -> None:
        self.table.setRowCount(0)
        for sale_id, date, label, amount in fetch_all_sales(
            db_path
        ):
            row = self.table.rowCount()
            self.table.insertRow(row)
            item_date = QTableWidgetItem(date)
            item_date.setData(Qt.UserRole, sale_id)
            self.table.setItem(row, 0, item_date)
            self.table.setItem(row, 1, QTableWidgetItem(label))
            self.table.setItem(row, 2, QTableWidgetItem(f"{amount:.2f}"))

    @Slot(int, int)
    def fill_fields_from_row(self, row: int, column: int) -> None:
        item_date = self.table.item(row, 0)
        item_label = self.table.item(row, 1)
        item_amount = self.table.item(row, 2)
        if item_date and item_label and item_amount:
            self.date_edit.setDate(
                QDate.fromString(item_date.text(), "yyyy-MM-dd")
            )
            self.label_edit.setText(item_label.text())
            self.amount_spin.setValue(float(item_amount.text()))
